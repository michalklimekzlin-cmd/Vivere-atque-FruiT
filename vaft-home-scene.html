<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Boy Flower Worlds</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.9);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #flower-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="flower-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = ot√°ƒçen√≠ svƒõt≈Ø ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-right">
          v0.2 ‚Ä¢ VaF'i'T Boy Flower Worlds
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("flower-canvas");
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;

      let width = 0;
      let height = 0;

      // kamera (jen zoom + m√≠rn√Ω n√°klon, rotace kvƒõtiny je jen kolem Y)
      let viewScale = 1;
      let targetViewScale = 1;
      let rotX = -0.3;
      let rotY = 0.4;

      let dragging = false;
      let lastX = 0;
      let lastY = 0;
      let pinchActive = false;
      let pinchStartDist = 0;
      let pinchStartScale = 1;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        setupScene();
      }

      // ---------- SC√âNA PODLE N√ÅKRESU ----------

      const letterSource =
        "VIVEREATQUEFRUITMICHALKLIMEKHLAVOUNVIRIPIKOSREVIA" +
        "VAFITGLYPHCOREWORLDNETWORKFLOWERPLANET";

      const letters = letterSource.split("");

      const planets = [];

      function setupScene() {
        planets.length = 0;

        const baseR = Math.min(width, height) * 0.11;

        // pozice vych√°zej√≠ z n√°ƒçrtku:
        // telefon vpravo dole, kvƒõtina ≈°ikmo nahoru doleva

        const cx = width * 0.48;
        const cy = height * 0.50;

        planets.push({
          // lev√° / hlavn√≠ koule
          cx: cx - baseR * 0.7,
          cy: cy - baseR * 0.2,
          r: baseR * 1.05,
          rotSpeed: 0.18,
          points: [],
          aura: [],
        });

        planets.push({
          // horn√≠ prav√°
          cx: cx + baseR * 0.9,
          cy: cy - baseR * 1.2,
          r: baseR * 0.75,
          rotSpeed: -0.22,
          points: [],
          aura: [],
        });

        planets.push({
          // spodn√≠ prav√°
          cx: cx + baseR * 1.0,
          cy: cy + baseR * 0.7,
          r: baseR * 0.8,
          rotSpeed: 0.25,
          points: [],
          aura: [],
        });

        // vygenerovat body pro ka≈ædou planetu
        planets.forEach((p, idx) => generateSpherePoints(p, 32 + idx * 6, 20));
      }

      function generateSpherePoints(planet, parallels, meridians) {
        planet.points = [];
        for (let j = 0; j <= parallels; j++) {
          const v = j / parallels;
          const lat = v * Math.PI - Math.PI / 2;
          for (let i = 0; i < meridians; i++) {
            const u = i / meridians;
            const lon = u * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            planet.points.push({
              x,
              y,
              z,
              phase: Math.random() * Math.PI * 2,
              charIndex: (i + j * meridians) % letters.length,
            });
          }
        }

        planet.aura = [];
        for (let k = 0; k < 120; k++) {
          const lat = (Math.random() * Math.PI - Math.PI / 2) * 0.98;
          const lon = Math.random() * Math.PI * 2;
          const r = 1.05 + Math.random() * 0.08;
          const x = r * Math.cos(lat) * Math.cos(lon);
          const y = r * Math.sin(lat);
          const z = r * Math.cos(lat) * Math.sin(lon);
          planet.aura.push({
            x,
            y,
            z,
            charIndex: k % letters.length,
            phase: Math.random() * Math.PI * 2,
          });
        }
      }

      function project3D(x, y, z) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        const sx = x2;
        const sy = y1;
        return { sx, sy, z: z2 };
      }

      function drawBackground() {
        const g = ctx.createRadialGradient(
          width * 0.5,
          height * 0.2,
          0,
          width * 0.5,
          height * 0.6,
          height * 0.9
        );
        g.addColorStop(0, "#0b0815");
        g.addColorStop(1, "#020108");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);
      }

      function drawBaseAndPhone() {
        // z√°kladna pod telefonem
        const baseCx = width * 0.72;
        const baseCy = height * 0.80;
        const baseRx = Math.min(width, height) * 0.15;
        const baseRy = baseRx * 0.35;

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(baseCx, baseCy, baseRx, baseRy, 0, 0, Math.PI * 2);
        const g = ctx.createRadialGradient(
          baseCx,
          baseCy - baseRy * 0.3,
          baseRx * 0.3,
          baseCx,
          baseCy,
          baseRx * 1.4
        );
        g.addColorStop(0, "rgba(255,210,160,0.3)");
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();

        // telefon ‚Äì podle tv√©ho obr√°zku (lehce 3D)
        const phoneH = Math.min(width, height) * 0.18;
        const phoneW = phoneH * 0.55;
        const px = baseCx - phoneW * 0.1;
        const py = baseCy - phoneH * 0.8;

        ctx.save();
        ctx.translate(px, py);

        // tƒõlo
        ctx.beginPath();
        const r = 16;
        ctx.moveTo(r, 0);
        ctx.lineTo(phoneW - r, 0);
        ctx.quadraticCurveTo(phoneW, 0, phoneW, r);
        ctx.lineTo(phoneW, phoneH - r);
        ctx.quadraticCurveTo(phoneW, phoneH, phoneW - r, phoneH);
        ctx.lineTo(r, phoneH);
        ctx.quadraticCurveTo(0, phoneH, 0, phoneH - r);
        ctx.lineTo(0, r);
        ctx.quadraticCurveTo(0, 0, r, 0);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, 0, 0, phoneH);
        bodyGrad.addColorStop(0, "#f5e9da");
        bodyGrad.addColorStop(1, "#dcc8ae");
        ctx.fillStyle = bodyGrad;
        ctx.shadowColor = "rgba(0,0,0,0.65)";
        ctx.shadowBlur = 18;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = "rgba(40,30,20,0.4)";
        ctx.stroke();

        // displej
        const inset = 10;
        const screenR = 10;
        ctx.beginPath();
        ctx.moveTo(inset + screenR, inset + 4);
        ctx.lineTo(phoneW - inset - screenR, inset + 4);
        ctx.quadraticCurveTo(
          phoneW - inset,
          inset + 4,
          phoneW - inset,
          inset + 4 + screenR
        );
        ctx.lineTo(phoneW - inset, phoneH - inset - 26 - screenR);
        ctx.quadraticCurveTo(
          phoneW - inset,
          phoneH - inset - 26,
          phoneW - inset - screenR,
          phoneH - inset - 26
        );
        ctx.lineTo(inset + screenR, phoneH - inset - 26);
        ctx.quadraticCurveTo(
          inset,
          phoneH - inset - 26,
          inset,
          phoneH - inset - 26 - screenR
        );
        ctx.lineTo(inset, inset + 4 + screenR);
        ctx.quadraticCurveTo(
          inset,
          inset + 4,
          inset + screenR,
          inset + 4
        );
        ctx.closePath();

        ctx.fillStyle = "#5a120c";
        ctx.fill();

        // kulat√© tlaƒç√≠tko s krou≈ækem
        const btnY = phoneH - inset - 10;
        const btnX = phoneW / 2;
        ctx.beginPath();
        ctx.arc(btnX, btnY, 9, 0, Math.PI * 2);
        ctx.fillStyle = "#f5e9da";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(btnX, btnY, 5, 0, Math.PI * 2);
        ctx.strokeStyle = "#5a120c";
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();

        return {
          phoneTopX: px + phoneW * 0.52,
          phoneTopY: py + phoneH * 0.18,
          baseCx,
          baseCy,
        };
      }

      function drawStems(anchor, planets) {
        ctx.save();
        ctx.strokeStyle = "rgba(255, 210, 170, 0.9)";
        ctx.lineWidth = 2.2;
        ctx.lineCap = "round";

        planets.forEach((p, i) => {
          ctx.beginPath();
          ctx.moveTo(anchor.phoneTopX, anchor.phoneTopY);

          const midX = (anchor.phoneTopX + p.cx) / 2;
          const midY = (anchor.phoneTopY + p.cy) / 2;

          // lehce jin√Ω ohyb pro ka≈ædou vƒõtev
          const offsetX = (i - 1) * 40;
          const offsetY = -80 - i * 10;

          ctx.quadraticCurveTo(
            midX + offsetX,
            midY + offsetY,
            p.cx,
            p.cy + p.r * 0.1
          );
          ctx.stroke();
        });

        ctx.restore();
      }

      function drawPlanets(time) {
        ctx.save();
        ctx.font = `${10 * viewScale}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        planets.forEach((planet) => {
          const { cx, cy, r, rotSpeed } = planet;

          // tƒõlo koule
          ctx.beginPath();
          ctx.arc(cx, cy, r * viewScale, 0, Math.PI * 2);
          const globeGrad = ctx.createRadialGradient(
            cx - r * 0.3 * viewScale,
            cy - r * 0.45 * viewScale,
            r * 0.4 * viewScale,
            cx,
            cy + r * 0.4 * viewScale,
            r * 1.3 * viewScale
          );
          globeGrad.addColorStop(0, "#261713");
          globeGrad.addColorStop(0.5, "#140c11");
          globeGrad.addColorStop(1, "#040208");
          ctx.fillStyle = globeGrad;
          ctx.fill();

          ctx.strokeStyle = "rgba(255, 197, 120, 0.95)";
          ctx.lineWidth = 1.3;
          ctx.shadowColor = "rgba(255, 197, 120, 0.8)";
          ctx.shadowBlur = 8;
          ctx.stroke();
          ctx.shadowBlur = 0;

          // p√≠smenka
          ctx.save();
          const localRotY = rotY + time * rotSpeed;
          const localRotX = rotX * 1.1;

          function projectLocal(x, y, z) {
            // lehk√° kopie project3D, ale bez posunu
            let y1 = y * Math.cos(localRotX) - z * Math.sin(localRotX);
            let z1 = y * Math.sin(localRotX) + z * Math.cos(localRotX);
            let x2 = x * Math.cos(localRotY) + z1 * Math.sin(localRotY);
            let z2 = -x * Math.sin(localRotY) + z1 * Math.cos(localRotY);
            return { x: x2, y: y1, z: z2 };
          }

          ctx.fillStyle = "rgba(255, 220, 170, 0.95)";
          ctx.shadowColor = "rgba(255, 200, 150, 0.8)";
          ctx.shadowBlur = 5;

          for (const p of planet.points) {
            const q = projectLocal(p.x, p.y, p.z);
            if (q.z < 0) continue;

            const sx = cx + q.x * r * viewScale;
            const sy = cy + q.y * r * viewScale;

            const flicker =
              0.65 + 0.35 * Math.sin(time * 1.6 + p.phase + q.z * 3.0);
            ctx.globalAlpha = flicker;

            ctx.fillText(letters[p.charIndex], sx, sy);
          }

          ctx.font = `${9 * viewScale}px system-ui`;
          for (const p of planet.aura) {
            const q = projectLocal(p.x, p.y, p.z);
            if (q.z < 0) continue;
            const sx = cx + q.x * r * 1.1 * viewScale;
            const sy = cy + q.y * r * 1.1 * viewScale;
            const wobble = Math.sin(time * 2 + p.phase) * 3 * viewScale;
            const alpha = 0.25 + 0.45 * Math.sin(time * 1.9 + p.phase);
            ctx.globalAlpha = alpha;
            ctx.fillText(letters[p.charIndex], sx, sy + wobble);
          }

          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
          ctx.restore();
        });

        ctx.restore();
      }

      function drawTitleBox() {
        // ≈°ikm√° 3D cedule vlevo naho≈ôe ‚Äì podle n√°ƒçrtku
        const boxW = Math.min(width, height) * 0.42;
        const boxH = boxW * 0.18;

        const baseX = width * 0.25;
        const baseY = height * 0.18;

        const depth = boxH * 0.35;

        ctx.save();

        // spodn√≠ obd√©ln√≠k
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.lineTo(baseX + boxW, baseY);
        ctx.lineTo(baseX + boxW * 0.96, baseY + boxH);
        ctx.lineTo(baseX - boxW * 0.04, baseY + boxH);
        ctx.closePath();

        const faceGrad = ctx.createLinearGradient(
          baseX,
          baseY,
          baseX,
          baseY + boxH
        );
        faceGrad.addColorStop(0, "#f9eedc");
        faceGrad.addColorStop(1, "#e5d1b5");
        ctx.fillStyle = faceGrad;
        ctx.shadowColor = "rgba(0,0,0,0.6)";
        ctx.shadowBlur = 18;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(60,45,35,0.55)";
        ctx.lineWidth = 1.3;
        ctx.stroke();

        // horn√≠ hrana (lehk√© 3D)
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.lineTo(baseX + depth, baseY - depth * 0.45);
        ctx.lineTo(baseX + depth + boxW, baseY - depth * 0.45);
        ctx.lineTo(baseX + boxW, baseY);
        ctx.closePath();
        const topGrad = ctx.createLinearGradient(
          baseX,
          baseY - depth,
          baseX,
          baseY
        );
        topGrad.addColorStop(0, "#fff7eb");
        topGrad.addColorStop(1, "#e8d7bf");
        ctx.fillStyle = topGrad;
        ctx.fill();
        ctx.stroke();

        // lev√Ω bok
        ctx.beginPath();
        ctx.moveTo(baseX, baseY);
        ctx.lineTo(baseX + depth, baseY - depth * 0.45);
        ctx.lineTo(baseX + depth - boxW * 0.04, baseY - depth * 0.45 + boxH);
        ctx.lineTo(baseX - boxW * 0.04, baseY + boxH);
        ctx.closePath();
        const sideGrad = ctx.createLinearGradient(
          baseX,
          baseY,
          baseX + depth,
          baseY + boxH
        );
        sideGrad.addColorStop(0, "#e4cfb2");
        sideGrad.addColorStop(1, "#c9b091");
        ctx.fillStyle = sideGrad;
        ctx.fill();
        ctx.stroke();

        // text uvnit≈ô (jen na ƒçeln√≠ plo≈°e)
        ctx.fillStyle = "#2c1e17";
        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const textCx = baseX + boxW * 0.48;
        const textCy = baseY + boxH * 0.38;

        ctx.fillText("Vivere", textCx, textCy - 10);
        ctx.fillText("atque", textCx, textCy + 12);
        ctx.fillText("FruiT", textCx, textCy + 34);

        ctx.restore();
      }

      // ---------- DRAW LOOP ----------

      let lastTime = 0;

      function draw(timestamp) {
        if (!timestamp) timestamp = 0;
        const t = timestamp / 1000;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        viewScale += (targetViewScale - viewScale) * Math.min(1, dt * 5);

        // m√≠rn√° auto-rotace
        rotY += dt * 0.08;

        ctx.clearRect(0, 0, width, height);
        drawBackground();

        const anchor = drawBaseAndPhone();
        drawStems(anchor, planets);
        drawPlanets(t);
        drawTitleBox();

        requestAnimationFrame(draw);
      }

      // ---------- INTERAKCE ----------

      function getPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const p = getPos(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        rotY += dx * 0.006;
        rotX += dy * 0.006;
        rotX = Math.max(-Math.PI / 2 + 0.15, Math.min(Math.PI / 2 - 0.15, rotX));
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          targetViewScale = Math.max(0.6, Math.min(2.4, viewScale * factor));
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            pinchActive = true;
            dragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchStartDist = Math.hypot(dx, dy);
            pinchStartScale = viewScale;
          } else if (e.touches.length === 1) {
            pinchActive = false;
            dragging = true;
            const p = getPos(e);
            lastX = p.x;
            lastY = p.y;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (pinchActive && e.touches.length === 2) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const ratio = dist / pinchStartDist;
            targetViewScale = Math.max(
              0.6,
              Math.min(2.4, pinchStartScale * ratio)
            );
            return;
          }
          if (dragging && e.touches.length === 1) {
            e.preventDefault();
            const p = getPos(e);
            const dx = p.x - lastX;
            const dy = p.y - lastY;
            lastX = p.x;
            lastY = p.y;
            rotY += dx * 0.006;
            rotX += dy * 0.006;
            rotX = Math.max(
              -Math.PI / 2 + 0.15,
              Math.min(Math.PI / 2 - 0.15, rotX)
            );
          }
        },
        { passive: false }
      );

      window.addEventListener("touchend", () => {
        dragging = false;
        pinchActive = false;
      });

      // ---------- START ----------

      resize();
      window.addEventListener("resize", resize);
      requestAnimationFrame(draw);
    </script>
  </body>
</html>
