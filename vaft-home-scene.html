<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Domovsk√° sc√©na</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.9);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #scene-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.8;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.8;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="scene-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = n√°klon svƒõt≈Ø ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-right">
          v0.1 ‚Ä¢ VaF'i'T Home ‚Ä¢ telefon ‚Üí kvƒõtina svƒõt≈Ø
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("scene-canvas");
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;

      let width = 0;
      let height = 0;
      let minWH = 0;

      // kamera / pohled
      let viewScale = 1;
      let targetViewScale = 1;
      let rotX = -0.25; // n√°klon nahoru/dol≈Ø
      let rotY = 0.35; // natoƒçen√≠ doleva/doprava

      // interakce
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      // layout sc√©ny
      const worlds = []; // napln√≠me po resize

      const letterSource =
        "VIVEREATQUEFRUITMICHALKLIMEKHLAVOUNVIRIPIKOSREVIA" +
        "VAFITGLYPHCORENETWORKGUARDIANCHYBOZROUTFUELWORLD";
      const letters = letterSource.split("");

      const sphereTemplate = {
        points: [],
        meridians: 40,
        parallels: 26,
      };

      function generateSphereTemplate() {
        sphereTemplate.points = [];
        const { meridians, parallels } = sphereTemplate;

        for (let j = 0; j <= parallels; j++) {
          const v = j / parallels;
          const lat = v * Math.PI - Math.PI / 2; // -90..+90
          for (let i = 0; i < meridians; i++) {
            const u = i / meridians;
            const lon = u * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);

            sphereTemplate.points.push({
              x,
              y,
              z,
              charIndex: (i + j * meridians) % letters.length,
              phase: Math.random() * Math.PI * 2,
            });
          }
        }
      }

      generateSphereTemplate();

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        minWH = Math.min(width, height);
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        setupWorldLayout();
      }

      function setupWorldLayout() {
        worlds.length = 0;

        const phoneHeight = minWH * 0.16;
        const phoneWidth = phoneHeight * 0.55;
        const baseY = height * 0.78;
        const phoneCenterX = width * 0.48;
        const phoneTopY = baseY - phoneHeight;

        const baseR = minWH * 0.09;

        // prost≈ôedn√≠ svƒõt ‚Äì hlavn√≠
        worlds.push({
          name: "core",
          cx: phoneCenterX + phoneWidth * 0.12,
          cy: phoneTopY - minWH * 0.14,
          radius: baseR * 1.05,
          rotOffset: 0,
          rotSpeed: 0.18,
        });

        // lev√Ω svƒõt ‚Äì o kousek men≈°√≠
        worlds.push({
          name: "left",
          cx: phoneCenterX - minWH * 0.16,
          cy: phoneTopY - minWH * 0.08,
          radius: baseR * 0.85,
          rotOffset: 1.3,
          rotSpeed: 0.23,
        });

        // prav√Ω svƒõt ‚Äì trochu n√≠≈æ
        worlds.push({
          name: "right",
          cx: phoneCenterX + minWH * 0.20,
          cy: phoneTopY - minWH * 0.02,
          radius: baseR * 0.9,
          rotOffset: 2.4,
          rotSpeed: 0.2,
        });

        // ulo≈æ√≠m layout telefonu pro kreslen√≠
        layout.phone = {
          cx: phoneCenterX,
          baseY,
          topY: phoneTopY,
          width: phoneWidth,
          height: phoneHeight,
        };

        layout.bubble = {
          width: minWH * 0.52,
          height: minWH * 0.12,
          // bublina nad prost≈ôedn√≠m svƒõtem
          cx: worlds[0].cx + minWH * 0.04,
          cy: worlds[0].cy - minWH * 0.19,
        };
      }

      const layout = {
        phone: null,
        bubble: null,
      };

      resize();
      window.addEventListener("resize", resize);

      // projekce 3D bodu (bez perspektivy, jen rotace)
      function projectLocal(x, y, z, cx, cy, scale) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        const sx = cx + x2 * scale * viewScale;
        const sy = cy + y1 * scale * viewScale;
        return { sx, sy, z: z2 };
      }

      // ---------- KRESLEN√ç POZAD√ç ----------
      function drawBackground() {
        const g = ctx.createRadialGradient(
          width * 0.5,
          height * 0.1,
          0,
          width * 0.5,
          height * 0.7,
          height * 0.95
        );
        g.addColorStop(0, "#0b0819");
        g.addColorStop(1, "#020108");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);
      }

      function drawBaseGlow() {
        if (!layout.phone) return;
        const { cx, baseY } = layout.phone;
        const baseR = minWH * 0.18 * viewScale;

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(cx, baseY, baseR * 1.5, baseR * 0.55, 0, 0, Math.PI * 2);
        const g = ctx.createRadialGradient(
          cx,
          baseY,
          baseR * 0.3,
          cx,
          baseY,
          baseR * 1.6
        );
        g.addColorStop(0, "rgba(255, 210, 160, 0.35)");
        g.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      // ---------- TELEFON ----------
      function drawPhone() {
        if (!layout.phone) return;
        const { cx, baseY, topY, width: w, height: h } = layout.phone;

        const x = cx - w / 2;
        const y = topY;

        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(255, 232, 210, 0.95)";
        ctx.fillStyle = "rgba(16, 10, 8, 0.95)";
        ctx.shadowColor = "rgba(255, 210, 160, 0.7)";
        ctx.shadowBlur = 8;

        const r = w * 0.22;

        // tƒõlo telefonu
        roundRect(ctx, x, y, w, h, r);
        ctx.fill();
        ctx.stroke();

        // displej
        const padX = w * 0.16;
        const padY = h * 0.18;
        ctx.shadowBlur = 4;
        ctx.fillStyle = "#5a120a";
        roundRect(
          ctx,
          x + padX,
          y + padY,
          w - padX * 2,
          h - padY * 2.1,
          w * 0.12
        );
        ctx.fill();

        // kruhov√© logo uprost≈ôed
        const logoCx = cx;
        const logoCy = y + h * 0.44;
        const logoR = w * 0.13;
        ctx.beginPath();
        ctx.arc(logoCx, logoCy, logoR, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(245, 220, 205, 0.95)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // home button
        ctx.beginPath();
        ctx.arc(cx, y + h * 0.86, w * 0.06, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(245, 220, 205, 0.9)";
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.lineTo(x + w - rr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
        ctx.lineTo(x + w, y + h - rr);
        ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
        ctx.lineTo(x + rr, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
        ctx.lineTo(x, y + rr);
        ctx.quadraticCurveTo(x, y, x + rr, y);
        ctx.closePath();
      }

      // ---------- STONKY ----------
      function drawStems() {
        if (!layout.phone || worlds.length === 0) return;
        const { cx: px, topY } = layout.phone;

        ctx.save();
        ctx.lineWidth = 1.8;
        ctx.strokeStyle = "rgba(255, 220, 180, 0.9)";
        ctx.shadowColor = "rgba(255, 210, 160, 0.9)";
        ctx.shadowBlur = 6;

        const startX = px;
        const startY = topY + minWH * 0.02;

        worlds.forEach((w, index) => {
          const endX = w.cx;
          const endY = w.cy + w.radius * 0.1;

          // ovl√°dac√≠ bod ‚Äì r≈Øzn√© zak≈ôiven√≠ pro ka≈æd√Ω stonek
          let ctrlX = (startX + endX) / 2;
          let ctrlY = startY - minWH * 0.06;

          if (index === 0) {
            ctrlY = startY - minWH * 0.1;
          } else if (index === 1) {
            ctrlX -= minWH * 0.04;
          } else if (index === 2) {
            ctrlX += minWH * 0.05;
            ctrlY = startY - minWH * 0.04;
          }

          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
          ctx.stroke();
        });

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // ---------- PLANETY ----------
      function drawLetterWorld(world, time) {
        const { cx, cy, radius, rotOffset, rotSpeed } = world;

        ctx.save();
        // tƒõlo koule ‚Äì tmav√Ω disk
        ctx.beginPath();
        ctx.arc(cx, cy, radius * viewScale, 0, Math.PI * 2);
        const globeGrad = ctx.createRadialGradient(
          cx - radius * 0.3 * viewScale,
          cy - radius * 0.4 * viewScale,
          radius * 0.5 * viewScale,
          cx,
          cy + radius * 0.4 * viewScale,
          radius * 1.3 * viewScale
        );
        globeGrad.addColorStop(0, "#261713");
        globeGrad.addColorStop(0.5, "#140c11");
        globeGrad.addColorStop(1, "#040208");
        ctx.fillStyle = globeGrad;
        ctx.fill();

        ctx.strokeStyle = "rgba(255, 197, 120, 0.95)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 9;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();

        // p√≠smenka
        ctx.save();
        ctx.font = `${9 * viewScale}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 220, 170, 0.95)";
        ctx.shadowColor = "rgba(255, 200, 150, 0.8)";
        ctx.shadowBlur = 6;

        const selfRot = time * rotSpeed + rotOffset;

        for (const p of sphereTemplate.points) {
          // posuneme lon o selfRot, aby se planeta ot√°ƒçela
          const x = p.x * Math.cos(selfRot) - p.z * Math.sin(selfRot);
          const z = p.x * Math.sin(selfRot) + p.z * Math.cos(selfRot);
          const y = p.y;

          const proj = projectLocal(x, y, z, cx, cy, radius);

          if (proj.z < 0) continue;

          const flicker =
            0.55 + 0.45 * Math.sin(time * 1.5 + p.phase + proj.z * 2.0);
          ctx.globalAlpha = flicker;

          ctx.fillText(letters[p.charIndex], proj.sx, proj.sy);
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      function drawWorlds(time) {
        worlds.forEach((w) => drawLetterWorld(w, time));
      }

      // ---------- BUBLINA / CEDULE ----------
      function drawBubble() {
        if (!layout.bubble) return;
        const { cx, cy, width: bw, height: bh } = layout.bubble;

        const frontX = cx - bw / 2;
        const frontY = cy;
        const depth = bh * 0.35; // pseudo 3D hloubka doprava / nahoru

        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.9)";
        ctx.shadowBlur = 16;

        // horn√≠ plocha (nahnut√Ω obd√©ln√≠k)
        ctx.beginPath();
        ctx.moveTo(frontX + bw * 0.08, frontY);
        ctx.lineTo(frontX + bw * 0.9, frontY);
        ctx.lineTo(frontX + bw * 0.9 - depth * 0.9, frontY - depth);
        ctx.lineTo(frontX + bw * 0.08 - depth * 0.9, frontY - depth);
        ctx.closePath();
        ctx.fillStyle = "#f6ecde";
        ctx.fill();
        ctx.strokeStyle = "rgba(120,100,80,0.5)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // ƒçeln√≠ stƒõna
        const frontH = bh;
        const frontR = 12;

        const fx = frontX;
        const fy = frontY;
        const fw = bw;
        const fh = frontH;

        ctx.beginPath();
        ctx.moveTo(fx + frontR, fy);
        ctx.lineTo(fx + fw - frontR, fy);
        ctx.quadraticCurveTo(fx + fw, fy, fx + fw, fy + frontR);
        ctx.lineTo(fx + fw, fy + fh - frontR);
        ctx.quadraticCurveTo(fx + fw, fy + fh, fx + fw - frontR, fy + fh);
        ctx.lineTo(fx + frontR, fy + fh);
        ctx.quadraticCurveTo(fx, fy + fh, fx, fy + fh - frontR);
        ctx.lineTo(fx, fy + frontR);
        ctx.quadraticCurveTo(fx, fy, fx + frontR, fy);
        ctx.closePath();

        const frontGrad = ctx.createLinearGradient(
          fx,
          fy,
          fx,
          fy + fh + depth * 0.5
        );
        frontGrad.addColorStop(0, "#fdf3e4");
        frontGrad.addColorStop(1, "#e2d1bc");
        ctx.fillStyle = frontGrad;
        ctx.fill();
        ctx.stroke();

        // ‚Äústonek‚Äù z bubliny dol≈Ø k prost≈ôedn√≠mu svƒõtu
        const coreWorld = worlds[0];
        if (coreWorld) {
          ctx.beginPath();
          const stemStartX = cx;
          const stemStartY = fy + fh;
          const stemEndX = coreWorld.cx + coreWorld.radius * 0.05;
          const stemEndY = coreWorld.cy - coreWorld.radius * 0.7;

          const ctrlX = (stemStartX + stemEndX) / 2 + minWH * 0.02;
          const ctrlY = stemStartY + (stemEndY - stemStartY) * 0.3;

          ctx.moveTo(stemStartX, stemStartY);
          ctx.quadraticCurveTo(ctrlX, ctrlY, stemEndX, stemEndY);
          ctx.strokeStyle = "rgba(210, 170, 130, 0.9)";
          ctx.lineWidth = 1.4;
          ctx.stroke();
        }

        ctx.shadowBlur = 0;

        // text uvnit≈ô bubliny
        ctx.fillStyle = "#1c1510";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "16px system-ui";
        ctx.fillText("Vivere atque", cx, frontY + frontH * 0.4);
        ctx.font = "20px system-ui";
        ctx.fillText("FruiT", cx, frontY + frontH * 0.7);

        ctx.font = "10px system-ui";
        ctx.fillStyle = "rgba(60,40,30,0.9)";
        ctx.fillText(
          "svƒõty rostouc√≠ z jednoho telefonu",
          cx,
          frontY + frontH * 1.05
        );

        ctx.restore();
      }

      // ---------- HLAVN√ç LOOP ----------
      let lastTime = 0;
      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const t = timestamp / 1000;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        // plynul√© p≈ôibl√≠≈æen√≠
        const k = Math.min(1, dt * 5);
        viewScale += (targetViewScale - viewScale) * k;

        ctx.clearRect(0, 0, width, height);
        drawBackground();
        drawBaseGlow();
        drawStems();
        drawWorlds(t);
        drawPhone();
        drawBubble();

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      // ---------- INTERAKCE ----------
      function getPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const p = getPos(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        rotY += dx * 0.005;
        rotX += dy * 0.005;
        rotX = Math.max(-1.2, Math.min(0.2, rotX));
      });

      // wheel zoom
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          targetViewScale = Math.max(
            0.6,
            Math.min(2.4, targetViewScale * factor)
          );
        },
        { passive: false }
      );

      // touch
      canvas.addEventListener(
        "touchstart",
        (e) => {
          dragging = true;
          const p = getPos(e);
          lastX = p.x;
          lastY = p.y;
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (!dragging) return;
          const p = getPos(e);
          const dx = p.x - lastX;
          const dy = p.y - lastY;
          lastX = p.x;
          lastY = p.y;

          rotY += dx * 0.005;
          rotX += dy * 0.005;
          rotX = Math.max(-1.2, Math.min(0.2, rotX));
        },
        { passive: false }
      );

      window.addEventListener(
        "touchend",
        () => {
          dragging = false;
        },
        { passive: false }
      );
    </script>
  </body>
</html>
