<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Icecream Worlds + Live Signal Cone</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #globe-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-center {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        opacity: 0.85;
        text-align: center;
        white-space: nowrap;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="globe-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = n√°klon sc√©ny ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-center">
          5 koul√≠ svƒõta ‚Ä¢ ≈æiv√Ω glyphov√Ω kornout ‚Ä¢ Vivere prstenec
        </div>
        <div class="hud-right">
          v2.0 ‚Ä¢ VaF'i'T Icecream Worlds + Live Glyph Signal Cone
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("globe-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      let baseRadius = 0;
      const dpr = window.devicePixelRatio || 1;

      // kamera
      let viewScale = 1;
      let targetViewScale = 1;
      let viewOffsetX = 0;
      let viewOffsetY = 0;
      let targetViewOffsetX = 0;
      let targetViewOffsetY = 0;

      // n√°klon sc√©ny
      let globalTiltX = -0.8;
      let globalTiltY = 0.2;
      let targetTiltX = globalTiltX;
      let targetTiltY = globalTiltY;

      // ƒças / rotace skupiny
      let orbitRotation = 0;

      // pro textov√Ω prstenec
      let coreScreenX = 0;
      let coreScreenY = 0;

      // ---------- SPOLU SD√çLEN√Å PROJEKCE ----------

      function projectPoint(x, y, z) {
        const sinX = Math.sin(globalTiltX);
        const cosX = Math.cos(globalTiltX);
        const sinY = Math.sin(globalTiltY);
        const cosY = Math.cos(globalTiltY);

        let y1 = y * cosX - z * sinX;
        let z1 = y * sinX + z * cosX;

        let x2 = x * cosY + z1 * sinY;
        let z2 = -x * sinY + z1 * cosY;

        const sx = width / 2 + viewOffsetX + x2 * viewScale;
        const sy = height / 2 + viewOffsetY + y1 * viewScale;

        return { sx, sy, z: z2 };
      }

      function projectOnSphereVec(x, y, z, radius, rotX, rotY) {
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);
        const scale = radius;
        return { x: x2 * scale, y: y1 * scale, z: z2 };
      }

      // ---------- KOULE (5 kopeƒçk≈Ø) ----------

      const spheres = [
        {
          key: "core",
          name: "Vivere Core",
          ux: 0,
          uy: -0.9,
          uz: 0,
          phase: 0,
          radiusMul: 1.1,
          rotX: -0.3,
          rotY: 0.3,
          isCore: true,
        },
        {
          key: "world1",
          name: "Hra + pravidla",
          ux: -0.9,
          uy: -0.7,
          uz: 0.4,
          phase: 0.2,
          radiusMul: 0.8,
          rotX: -0.25,
          rotY: 0.8,
          isCore: false,
        },
        {
          key: "world2",
          name: "Hrdinov√©",
          ux: 0.9,
          uy: -0.7,
          uz: 0.4,
          phase: -0.3,
          radiusMul: 0.8,
          rotX: -0.25,
          rotY: -0.8,
          isCore: false,
        },
        {
          key: "world3",
          name: "Jazyk",
          ux: -0.7,
          uy: -0.4,
          uz: -0.3,
          phase: 0.7,
          radiusMul: 0.75,
          rotX: -0.3,
          rotY: 0.2,
          isCore: false,
        },
        {
          key: "world4",
          name: "Zemƒõ / √∫hel",
          ux: 0.7,
          uy: -0.4,
          uz: -0.3,
          phase: -0.6,
          radiusMul: 0.75,
          rotX: -0.15,
          rotY: -0.4,
          isCore: false,
        },
      ];

      function layoutSpheres() {
        const clusterScale = baseRadius * 1.9;

        for (const s of spheres) {
          const px = s.ux * clusterScale;
          const py = s.uy * clusterScale;
          const pz = s.uz * clusterScale;

          const a = orbitRotation * 0.35 + s.phase;
          const xOrbit = px * Math.cos(a) - pz * Math.sin(a);
          const zOrbit = px * Math.sin(a) + pz * Math.cos(a);

          const proj = projectPoint(xOrbit, py, zOrbit);
          s.cx = proj.sx;
          s.cy = proj.sy;
          s.depth = proj.z;
        }
      }

      function drawSphere(s) {
        const radius = baseRadius * s.radiusMul;

        ctx.save();
        ctx.translate(s.cx, s.cy);
        ctx.scale(viewScale, viewScale);

        if (s.isCore) {
          coreScreenX = s.cx;
          coreScreenY = s.cy;
        }

        // glow
        const gGlow = ctx.createRadialGradient(
          0,
          -radius * 0.2,
          radius * 0.3,
          0,
          0,
          radius * 1.8
        );
        gGlow.addColorStop(0, "rgba(255, 200, 150, 0.20)");
        gGlow.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = gGlow;
        ctx.fillRect(-radius * 2, -radius * 2, radius * 4, radius * 4);

        // tƒõlo koule
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        const globeGrad = ctx.createRadialGradient(
          -radius * 0.3,
          -radius * 0.4,
          radius * 0.3,
          0,
          radius * 0.4,
          radius * 1.1
        );
        globeGrad.addColorStop(0, "#2d1d0f");
        globeGrad.addColorStop(0.5, "#1b1012");
        globeGrad.addColorStop(1, "#050308");
        ctx.fillStyle = globeGrad;
        ctx.fill();

        // kontura
        ctx.strokeStyle = "rgba(255, 197, 120, 0.95)";
        ctx.lineWidth = 1.3;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 8;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // dr√°tov√° m≈ô√≠≈æka
        ctx.lineWidth = 0.7;
        ctx.strokeStyle = "rgba(255, 210, 145, 0.85)";

        const meridians = 12;
        const parallels = 8;

        for (let i = 0; i < meridians; i++) {
          const lon = (i / meridians) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let sStep = 0; sStep <= 60; sStep++) {
            const t = (sStep / 60) * Math.PI - Math.PI / 2;
            const x = Math.cos(t) * Math.cos(lon);
            const y = Math.sin(t);
            const z = Math.cos(t) * Math.sin(lon);
            const p = projectOnSphereVec(x, y, z, radius * 0.95, s.rotX, s.rotY);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        for (let j = 1; j < parallels; j++) {
          const lat = (j / parallels) * Math.PI - Math.PI / 2;
          ctx.beginPath();
          let started = false;
          for (let sStep = 0; sStep <= 90; sStep++) {
            const lon = (sStep / 90) * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            const p = projectOnSphereVec(x, y, z, radius * 0.95, s.rotX, s.rotY);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        // n√°zev pod koul√≠
        if (!s.isCore) {
          ctx.save();
          ctx.font = "9px system-ui";
          ctx.fillStyle = "rgba(255,220,170,0.9)";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.shadowColor = "rgba(0,0,0,0.8)";
          ctx.shadowBlur = 6;
          ctx.fillText(s.name, 0, radius + 6);
          ctx.restore();
        }

        // prstenec u core koule
        if (s.isCore) {
          ctx.save();
          const ringRadiusX = radius * 1.25;
          const ringRadiusY = radius * 0.45;
          ctx.rotate(orbitRotation * 0.6);
          ctx.beginPath();
          ctx.ellipse(0, 0, ringRadiusX, ringRadiusY, 0, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(255, 230, 180, 0.95)";
          ctx.lineWidth = 1.4;
          ctx.shadowColor = "rgba(255, 210, 160, 0.9)";
          ctx.shadowBlur = 10;
          ctx.stroke();
          ctx.shadowBlur = 0;
          ctx.restore();
        }

        ctx.restore();
      }

      // ---------- TEXTOV√ù VIVERE PRSTENEC ----------

      const vivereText = "{*(¬∞.).)// Vivere atque FruiT \\\\(.(.¬∞)*}";

      function drawVivereRing() {
        if (!coreScreenX && !coreScreenY) return;

        const radius = baseRadius * 2.4 * viewScale;
        const step = (Math.PI * 2) / vivereText.length;
        const baseAngle = orbitRotation * 0.4;

        ctx.save();
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 220, 170, 0.92)";
        ctx.shadowColor = "rgba(255, 200, 150, 0.8)";
        ctx.shadowBlur = 8;

        for (let i = 0; i < vivereText.length; i++) {
          const ch = vivereText[i];
          const angle = baseAngle + i * step;
          const x = coreScreenX + Math.cos(angle) * radius;
          const y = coreScreenY + Math.sin(angle) * radius * 0.35;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle + Math.PI / 2);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // ---------- ≈ΩIV√ù SIGN√ÅLOV√ù KU≈ΩEL ----------

      const glyphs = ["{*(¬∞.)}", "Ÿã&‚Äô„Äç", "¬°(*)(%)¬°", "{¬∞. .}", "(‚Ä¢.¬∞)"];
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const codePieces = [
        "if(VaFiT){emit(worlds);}",
        "glyph[i++]",
        "signal();",
        "core.sync();",
        "for(letter of glyph){ }",
      ];

      const bigCone = {
        radiusTop: 300,
        radiusBottom: 50,
        height: 400,
        offsetY: 0,
      };

      const signalParticles = [];

      function initSignalCone() {
        signalParticles.length = 0;
        const count = 260; // m√≠≈à ne≈æ p≈ôedt√≠m ‚Äì v√≠c vzduchu
        for (let i = 0; i < count; i++) {
          const kindRand = Math.random();
          let kind = "glyph";
          if (kindRand > 0.7 && kindRand <= 0.9) kind = "letter";
          else if (kindRand > 0.9) kind = "code";

          signalParticles.push({
            t: Math.random(), // 0 = ≈°piƒçka dole, 1 = naho≈ôe u planet
            angle: Math.random() * Math.PI * 2,
            radiusJitter: 0.3 + Math.random() * 0.7,
            kind,
            phase: Math.random() * Math.PI * 2,
            speed: 0.08 + Math.random() * 0.12,
          });
        }
      }

      function updateSignalCone(dt) {
        for (const p of signalParticles) {
          p.t += p.speed * dt; // proud smƒõrem NAHORU
          if (p.t > 1) p.t -= 1;
        }
      }

      function drawSignalCone() {
        // st√≠n pod ku≈æelem (≈°piƒçka)
        ctx.save();
        ctx.translate(width / 2 + viewOffsetX, height / 2 + viewOffsetY);
        ctx.scale(viewScale, viewScale);

        const tipY = bigCone.offsetY + bigCone.height;
        ctx.beginPath();
        ctx.ellipse(
          0,
          tipY + bigCone.radiusBottom * 0.4,
          bigCone.radiusBottom * 1.6,
          bigCone.radiusBottom * 0.6,
          0,
          0,
          Math.PI * 2
        );
        const shadowGrad = ctx.createRadialGradient(
          0,
          tipY + bigCone.radiusBottom * 0.4,
          bigCone.radiusBottom * 0.3,
          0,
          tipY + bigCone.radiusBottom * 0.4,
          bigCone.radiusBottom * 2.0
        );
        shadowGrad.addColorStop(0, "rgba(10,6,4,0.9)");
        shadowGrad.addColorStop(1, "rgba(0,0,0,0.0)");
        ctx.fillStyle = shadowGrad;
        ctx.fill();
        ctx.restore();

        // jemn√° dr√°tov√° silueta ku≈æele ‚Äì aby byl tvar ƒçiteln√Ω
        ctx.save();
        ctx.translate(width / 2 + viewOffsetX, height / 2 + viewOffsetY);
        ctx.scale(viewScale, viewScale);
        ctx.strokeStyle = "rgba(255, 210, 150, 0.28)";
        ctx.lineWidth = 0.7;

        const steps = 5;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const y = bigCone.offsetY + t * bigCone.height;
          const r =
            bigCone.radiusTop -
            (bigCone.radiusTop - bigCone.radiusBottom) * t;
          ctx.beginPath();
          ctx.ellipse(0, y, r, r * 0.45, 0, 0, Math.PI * 2);
          ctx.stroke();
        }

        // dvƒõ ‚Äûnosn√©‚Äú ƒç√°ry ‚Äì jako paprsky, kter√© dr≈æ√≠ planety
        ctx.beginPath();
        ctx.moveTo(0, bigCone.offsetY);
        ctx.lineTo(-bigCone.radiusTop * 0.6, bigCone.offsetY + bigCone.height);
        ctx.moveTo(0, bigCone.offsetY);
        ctx.lineTo(bigCone.radiusTop * 0.6, bigCone.offsetY + bigCone.height);
        ctx.stroke();

        ctx.restore();

        // samotn√© pohybuj√≠c√≠ se znaky uvnit≈ô ku≈æele
        ctx.save();
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 220, 170, 0.9)";
        ctx.shadowColor = "rgba(255, 200, 150, 0.7)";
        ctx.shadowBlur = 6;

        const letterLen = letters.length;
        const glyphLen = glyphs.length;

        for (let i = 0; i < signalParticles.length; i++) {
          const p = signalParticles[i];

          const t = p.t;
          const yLocal = bigCone.offsetY + (1 - t) * bigCone.height; // 1‚Üínaho≈ôe, 0‚Üí≈°piƒçka
          const rBase =
            bigCone.radiusTop -
            (bigCone.radiusTop - bigCone.radiusBottom) * (1 - t);
          const r = rBase * p.radiusJitter;

          const xLocal = Math.cos(p.angle) * r;
          const zLocal = Math.sin(p.angle) * r * 0.4; // lehce zplo≈°tƒõl√©

          const proj = projectPoint(xLocal, yLocal, zLocal);

          let text = "";
          if (p.kind === "glyph") {
            text = glyphs[i % glyphLen];
          } else if (p.kind === "letter") {
            text = letters[i % letterLen];
          } else {
            text = codePieces[i % codePieces.length];
          }

          const flicker =
            0.5 + 0.4 * Math.sin(orbitRotation * 0.9 + p.phase + i * 0.02);
          ctx.globalAlpha = flicker;

          ctx.fillText(text, proj.sx, proj.sy);
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // ---------- SC√âNA & ANIMACE ----------

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        baseRadius = Math.min(width, height) * 0.16;

        bigCone.radiusTop = baseRadius * 2.4;
        bigCone.radiusBottom = baseRadius * 0.55;
        bigCone.height = baseRadius * 3.4;
        bigCone.offsetY = baseRadius * 0.2; // top ku≈æelu lehce pod koulemi

        initSignalCone();
      }

      resize();
      window.addEventListener("resize", resize);

      function drawScene(dt) {
        ctx.clearRect(0, 0, width, height);

        layoutSpheres();
        drawSignalCone();

        const sorted = [...spheres].sort((a, b) => a.depth - b.depth);
        for (const s of sorted) drawSphere(s);

        drawVivereRing();
      }

      let lastTime = 0;
      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        const k = Math.min(1, dt * 5);
        viewScale += (targetViewScale - viewScale) * k;
        viewOffsetX += (targetViewOffsetX - viewOffsetX) * k;
        viewOffsetY += (targetViewOffsetY - viewOffsetY) * k;
        globalTiltX += (targetTiltX - globalTiltX) * k;
        globalTiltY += (targetTiltY - globalTiltY) * k;

        orbitRotation += dt * 0.45;
        updateSignalCone(dt);

        drawScene(dt);
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      // ---------- INTERAKCE ----------

      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      function getClientPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        const p = getClientPos(e);
        lastX = p.x;
        lastY = p.y;
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const p = getClientPos(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        targetTiltY += dx * 0.005;
        targetTiltX += dy * 0.005;
        const limit = 1.2;
        targetTiltX = Math.max(-limit, Math.min(limit, targetTiltX));
      });

      // touch ‚Äì drag nebo pinch zoom
      let pinchStartDist = 0;
      let pinchStartScale = 1;

      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 1) {
            dragging = true;
            const p = getClientPos(e);
            lastX = p.x;
            lastY = p.y;
          } else if (e.touches.length === 2) {
            dragging = false;
            const dx =
              e.touches[0].clientX - e.touches[1].clientX;
            const dy =
              e.touches[0].clientY - e.touches[1].clientY;
            pinchStartDist = Math.hypot(dx, dy);
            pinchStartScale = viewScale;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length === 1 && dragging) {
            const p = getClientPos(e);
            const dx = p.x - lastX;
            const dy = p.y - lastY;
            lastX = p.x;
            lastY = p.y;

            targetTiltY += dx * 0.005;
            targetTiltX += dy * 0.005;
            const limit = 1.2;
            targetTiltX = Math.max(-limit, Math.min(limit, targetTiltX));
          } else if (e.touches.length === 2) {
            const dx =
              e.touches[0].clientX - e.touches[1].clientX;
            const dy =
              e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const ratio = dist / pinchStartDist;
            targetViewScale = Math.max(
              0.7,
              Math.min(3.0, pinchStartScale * ratio)
            );
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchend",
        () => {
          if (event.touches && event.touches.length === 0) {
            dragging = false;
          }
        },
        { passive: false }
      );

      // wheel zoom
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          let newScale = viewScale * factor;
          newScale = Math.max(0.7, Math.min(3.0, newScale));
          targetViewScale = newScale;
        },
        { passive: false }
      );
    </script>
  </body>
</html>
