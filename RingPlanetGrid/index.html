<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Croissant Signal</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #sphere-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .hud-center {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        opacity: 0.8;
        text-align: center;
        white-space: nowrap;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="sphere-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = n√°klon ‚Ä¢ ≈•uk / klik = zmƒõna m√≥du ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-center" id="status">
          re≈æim: p√≠smenka / ƒç√≠sla
        </div>
        <div class="hud-right">v0.2 ¬∑ VaF'i'T Croissant Signal</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("sphere-canvas");
      const ctx = canvas.getContext("2d");
      const statusEl = document.getElementById("status");

      const dpr = window.devicePixelRatio || 1;
      let width = 0;
      let height = 0;
      let radius = 0;
      let viewScale = 1;
      let rotX = -0.4;
      let rotY = 0.5;

      // 0 = s√≠≈•, 1 = p√≠smenka/ƒç√≠sla, 2 = kapky, 3 = glyph
      let currentMode = 1;
      const modeNames = ["s√≠≈•", "p√≠smenka / ƒç√≠sla", "VaF'i'T kapky", "glyph"];

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        radius = Math.min(width, height) * 0.22;
      }

      resize();
      window.addEventListener("resize", resize);

      // --- parametry croissantu (zak≈ôiven√Ω torusov√Ω segment) ---

      const CROISSANT_SPAN_STEPS = 32; // d√©lka croissantu
      const CROISSANT_RING_STEPS = 18; // tlou≈°≈•ka

      function createCroissantPoints() {
        const points = [];
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const digits = "0123456789";
        const glyphs = [
          "{*(¬∞.).)//",
          "¬°(¬∞‚Äø¬∞)¬°",
          "(‚Ä¢‚ó°‚Ä¢)",
          "{(o,o)}",
          "7¬°A|V|A7¬°",
          "{*(‚Ä¢.)(.‚Ä¢)*}//"
        ];

        let idx = 0;

        // hlavn√≠ polomƒõr a tlou≈°≈•ka (v jednotk√°ch 1 ~ velikost koule)
        const majorR = 1.4;
        const minorBase = 0.55;
        const centerShiftX = majorR * 0.8; // posuneme trochu doleva, aby byl st≈ôed v z√°bƒõru

        for (let i = 0; i <= CROISSANT_SPAN_STEPS; i++) {
          const t = i / CROISSANT_SPAN_STEPS; // 0..1 po d√©lce
          const u = (t - 0.5) * Math.PI * 1.1; // oblouk cca 200¬∞

          // ztlu≈°tƒõn√≠ uprost≈ôed, z√∫≈æen√≠ na konc√≠ch
          const taper =
            0.7 + 0.3 * Math.cos((t - 0.5) * Math.PI * 2); // 0.4..1.0
          const minorR = minorBase * taper;

          for (let j = 0; j <= CROISSANT_RING_STEPS; j++) {
            const v = (j / CROISSANT_RING_STEPS) * Math.PI * 2;

            const ringX = (majorR + minorR * Math.cos(v)) * Math.cos(u);
            const ringZ = (majorR + minorR * Math.cos(v)) * Math.sin(u);
            const ringY = minorR * Math.sin(v) * 0.8; // lehce zplacat√≠me

            const worldX = ringX - centerShiftX;
            const worldY = ringY;
            const worldZ = ringZ;

            const letter = letters[idx % letters.length];
            const digit = digits[idx % digits.length];
            const glyph = glyphs[idx % glyphs.length];

            points.push({
              x: worldX,
              y: worldY,
              z: worldZ,
              letter,
              digit,
              glyph,
              dropPhase: (idx % 20) / 20
            });

            idx++;
          }
        }

        return points;
      }

      const points = createCroissantPoints();

      function projectPoint(px, py, pz) {
        // rotace kolem X
        let y1 = py * Math.cos(rotX) - pz * Math.sin(rotX);
        let z1 = py * Math.sin(rotX) + pz * Math.cos(rotX);
        // rotace kolem Y
        let x2 = px * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -px * Math.sin(rotY) + z1 * Math.cos(rotY);

        const scale = radius * viewScale;
        return {
          x: x2 * scale,
          y: y1 * scale,
          z: z2
        };
      }

      // --- kreslen√≠ ---

      function drawCroissant() {
        ctx.clearRect(0, 0, width, height);

        ctx.save();
        ctx.translate(width / 2, height / 2 + 15);

        // jemn√Ω glow pozad√≠ (stejn√Ω feeling jako koule)
        const gBg = ctx.createRadialGradient(
          0,
          -radius * 1.0,
          radius * 0.3,
          0,
          0,
          radius * 3.0
        );
        gBg.addColorStop(0, "rgba(255, 210, 150, 0.15)");
        gBg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gBg;
        ctx.fillRect(-width, -height, width * 2, height * 2);

        // ov√°ln√Ω st√≠n pod croissantem
        ctx.beginPath();
        ctx.ellipse(
          0,
          radius * 1.0,
          radius * 1.8,
          radius * 0.55,
          0,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(0,0,0,0.78)";
        ctx.fill();

        // ‚Äûtƒõlo‚Äú ‚Äì tmav√Ω podklad jako koule, jen ≈°ir≈°√≠
        ctx.beginPath();
        ctx.ellipse(
          0,
          -radius * 0.05,
          radius * 1.6 * viewScale,
          radius * 1.0 * viewScale,
          0,
          0,
          Math.PI * 2
        );
        const bodyGrad = ctx.createRadialGradient(
          -radius * 0.4,
          -radius * 0.5,
          radius * 0.3,
          0,
          radius * 0.6,
          radius * 2.0
        );
        bodyGrad.addColorStop(0, "#2d1d0f");
        bodyGrad.addColorStop(0.5, "#1b1012");
        bodyGrad.addColorStop(1, "#050308");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // zlat√Ω okraj (obrys cel√©ho croissantu jako "aury")
        ctx.strokeStyle = "rgba(255, 197, 120, 0.9)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.ellipse(
          0,
          -radius * 0.05,
          radius * 1.6 * viewScale,
          radius * 1.0 * viewScale,
          0,
          0,
          Math.PI * 2
        );
        ctx.stroke();
        ctx.shadowBlur = 0;

        // projekce bod≈Ø
        const projected = points.map((p) => {
          const proj = projectPoint(p.x, p.y, p.z);
          return { ...p, sx: proj.x, sy: proj.y, sz: proj.z };
        });
        projected.sort((a, b) => a.sz - b.sz);

        // --- M√≥d 0: dr√°tov√° s√≠≈• croissantu ---
        if (currentMode === 0) {
          ctx.strokeStyle = "rgba(255,210,150,0.7)";
          ctx.lineWidth = 0.7;

          const cols = CROISSANT_RING_STEPS + 1;
          const rows = CROISSANT_SPAN_STEPS + 1;

          // "pod√©ln√©" linky (po d√©lce croissantu)
          for (let i = 0; i < rows; i++) {
            ctx.beginPath();
            let started = false;
            for (let j = 0; j < cols; j++) {
              const idx = i * cols + j;
              const p = projected[idx];
              if (p.sz < 0) continue;
              if (!started) {
                ctx.moveTo(p.sx, p.sy);
                started = true;
              } else {
                ctx.lineTo(p.sx, p.sy);
              }
            }
            if (started) ctx.stroke();
          }

          // "p√°sy" kolem pr≈Ø≈ôezu
          for (let j = 0; j < cols; j++) {
            ctx.beginPath();
            let started = false;
            for (let i = 0; i < rows; i++) {
              const idx = i * cols + j;
              const p = projected[idx];
              if (p.sz < 0) continue;
              if (!started) {
                ctx.moveTo(p.sx, p.sy);
                started = true;
              } else {
                ctx.lineTo(p.sx, p.sy);
              }
            }
            if (started) ctx.stroke();
          }
        } else {
          // --- M√≥dy 1‚Äì3: p√≠smenka, kapky, glyphy ---

          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(255,210,150,0.8)";
          const now = performance.now() / 1000;

          for (const p of projected) {
            if (p.sz < 0) continue; // zadn√≠ strana schovan√°

            // mapujeme hloubku (-?,? z croissantu) na 0..1
            const depthNorm = Math.max(
              0,
              Math.min(1, (p.sz + 2.2) / 4.4)
            );
            const depthFade = 0.3 + 0.7 * depthNorm;

            if (currentMode === 1) {
              // p√≠smenka / ƒç√≠sla
              const isOuter = p.y > 0.0; // "vr≈°ek" = p√≠smenka, spodek = ƒç√≠sla
              const char = isOuter ? p.letter : p.digit;
              ctx.font = (isOuter ? 11 : 10) + "px system-ui";
              ctx.fillStyle = `rgba(255, 220, 180, ${
                0.45 + 0.55 * depthFade
              })`;
              ctx.shadowBlur = 6 * depthFade;
              ctx.fillText(char, p.sx, p.sy);
            } else if (currentMode === 2) {
              // kapky
              const flicker =
                0.4 +
                0.6 *
                  Math.abs(
                    Math.sin(now * 2.2 + p.dropPhase * Math.PI * 2)
                  );
              const r = 1.9 * viewScale * (0.6 + depthFade);
              ctx.beginPath();
              ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255, 220, 170, ${
                0.32 + 0.5 * depthFade * flicker
              })`;
              ctx.shadowBlur = 8 * depthFade;
              ctx.fill();
            } else if (currentMode === 3) {
              // glyph
              ctx.font = "9px system-ui";
              ctx.fillStyle = `rgba(255, 230, 190, ${
                0.4 + 0.6 * depthFade
              })`;
              ctx.shadowBlur = 7 * depthFade;
              ctx.fillText(p.glyph, p.sx, p.sy);
            }
          }
        }

        ctx.restore();
      }

      // --- animace ---

      let lastTime = 0;
      function loop(ts) {
        if (!ts) ts = 0;
        const dt = (ts - lastTime) / 1000;
        lastTime = ts;

        rotY += dt * 0.18; // pomal√° auto-rotace

        drawCroissant();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // --- interakce ---

      let drag = false;
      let lastX = 0;
      let lastY = 0;

      function pointerDown(e) {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        drag = true;
        lastX = touch.clientX;
        lastY = touch.clientY;
      }

      function pointerMove(e) {
        if (!drag) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const dx = touch.clientX - lastX;
        const dy = touch.clientY - lastY;
        lastX = touch.clientX;
        lastY = touch.clientY;

        rotY += dx * 0.004;
        rotX += dy * 0.004;
      }

      function pointerUp(e) {
        if (!drag) return;
        e.preventDefault();
        drag = false;
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      window.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp, { passive: false });
      window.addEventListener("touchcancel", pointerUp, { passive: false });

      // klik = zmƒõna m√≥du
      canvas.addEventListener("click", () => {
        currentMode = (currentMode + 1) % 4;
        statusEl.textContent = "re≈æim: " + modeNames[currentMode];
        drawCroissant();
      });

      // zoom
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        viewScale *= factor;
        viewScale = Math.max(0.6, Math.min(2.4, viewScale));
      });
    </script>
  </body>
</html>
