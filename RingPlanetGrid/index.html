<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T • Canvas Ring + Croissant</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #scene {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 16px;
        top: 12px;
        font-size: 11px;
        opacity: 0.8;
        background: rgba(5, 8, 20, 0.82);
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="scene"></canvas>
        <div class="hud">
          Ring + croissant • prsty = náklon • pinch / kolečko = zoom
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("scene");
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;

      let width = 0;
      let height = 0;
      let baseSize = 1;

      // "kamera"
      let viewScale = 1.1;
      let targetScale = 1.1;
      let tiltX = -0.45;
      let tiltY = 0.4;
      let targetTiltX = tiltX;
      let targetTiltY = tiltY;

      let orbitAngle = 0;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        baseSize = Math.min(width, height) * 0.22;
      }

      window.addEventListener("resize", resize);
      resize();

      // pseudo-3D projekce
      function project3D(x, y, z) {
        let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
        let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
        let x2 = x * Math.cos(tiltY) + z1 * Math.sin(tiltY);
        let z2 = -x * Math.sin(tiltY) + z1 * Math.cos(tiltY);

        return {
          x: x2 * viewScale,
          y: y1 * viewScale,
          z: z2,
        };
      }

      // podlaha
      function drawFloor() {
        ctx.save();
        ctx.translate(width / 2, height / 2);

        const size = baseSize * 4;
        const step = baseSize * 0.4;

        ctx.strokeStyle = "rgba(90,110,180,0.4)";
        ctx.lineWidth = 0.6;

        for (let x = -size; x <= size; x += step) {
          const p1 = project3D(x, 0, -size);
          const p2 = project3D(x, 0, size);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y + baseSize * 1.2);
          ctx.lineTo(p2.x, p2.y + baseSize * 1.2);
          ctx.stroke();
        }

        for (let z = -size; z <= size; z += step) {
          const p1 = project3D(-size, 0, z);
          const p2 = project3D(size, 0, z);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y + baseSize * 1.2);
          ctx.lineTo(p2.x, p2.y + baseSize * 1.2);
          ctx.stroke();
        }

        ctx.restore();
      }

      // prstenec
      function drawRing() {
        ctx.save();
        ctx.translate(width / 2, height / 2);

        const rOuter = baseSize * 1.15;
        const rInner = baseSize * 0.55;
        const segments = 120;

        function ringPath(radius) {
          ctx.beginPath();
          for (let i = 0; i <= segments; i++) {
            const a = (i / segments) * Math.PI * 2;
            const x = Math.cos(a) * radius;
            const z = Math.sin(a) * radius;
            const p = project3D(x, 0, z);
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.closePath();
        }

        // stín
        const pShadow = project3D(0, 0, 0);
        ctx.save();
        ctx.translate(pShadow.x, pShadow.y + baseSize * 1.05);
        ctx.scale(viewScale, viewScale * 0.35);
        const gs = ctx.createRadialGradient(0, 0, rInner * 0.1, 0, 0, rOuter);
        gs.addColorStop(0, "rgba(0,0,0,0.9)");
        gs.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gs;
        ctx.beginPath();
        ctx.ellipse(0, 0, rOuter, rOuter, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // prstenec tělo
        ringPath(rOuter);
        const gOuter = ctx.createLinearGradient(
          -rOuter,
          -rOuter,
          rOuter,
          rOuter
        );
        gOuter.addColorStop(0, "#fdf7ff");
        gOuter.addColorStop(0.4, "#f0e7ff");
        gOuter.addColorStop(1, "#c7d0ff");
        ctx.fillStyle = gOuter;
        ctx.fill();

        // vnitřní díra
        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        ringPath(rInner);
        ctx.fill();
        ctx.restore();

        // okraj
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = "rgba(40,80,150,0.8)";
        ringPath(rOuter);
        ctx.stroke();

        ctx.restore();
      }

      // ---------- CROISSANT: styl zlaté koule ----------

      function drawCroissantBody(localScale = 1) {
        const w = 2.6 * localScale;
        const h = 1.25 * localScale;

        // základní tvar croissantu
        ctx.beginPath();
        ctx.moveTo(-w * 0.9, 0);
        ctx.quadraticCurveTo(-w * 0.45, -h * 1.0, 0, -h * 1.1);
        ctx.quadraticCurveTo(w * 0.45, -h * 1.0, w * 0.9, 0);
        ctx.quadraticCurveTo(w * 0.45, h * 0.95, 0, h * 1.05);
        ctx.quadraticCurveTo(-w * 0.45, h * 0.95, -w * 0.9, 0);
        ctx.closePath();

        // výřez vpravo (uštip)
        ctx.save();
        ctx.clip();
        ctx.beginPath();
        ctx.arc(w * 0.7, 0, w * 0.55, -Math.PI / 3, Math.PI / 3, false);
        ctx.globalCompositeOperation = "destination-out";
        ctx.fill();
        ctx.restore();
        ctx.globalCompositeOperation = "source-over";

        // tělo jako tmavá koule se světelným středem
        ctx.save();
        ctx.clip();

        const grad = ctx.createRadialGradient(
          -w * 0.2,
          -h * 0.3,
          w * 0.1,
          0,
          h * 0.6,
          w * 1.4
        );
        grad.addColorStop(0, "#1b1012");
        grad.addColorStop(0.45, "#0e0709");
        grad.addColorStop(1, "#020205");
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.restore();

        // vnější zlatý okraj (jako koule)
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = "rgba(255, 210, 150, 0.96)";
        ctx.shadowColor = "rgba(255, 200, 130, 0.85)";
        ctx.shadowBlur = 8;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // zlatá mřížka – svislé "meridiány"
        ctx.save();
        ctx.strokeStyle = "rgba(255, 220, 170, 0.85)";
        ctx.lineWidth = 0.9;

        const cols = 9;
        for (let i = 0; i <= cols; i++) {
          const t = i / cols;
          const cx = -w * 0.75 + t * w * 1.5;
          ctx.beginPath();
          for (let j = 0; j <= 16; j++) {
            const u = j / 16;
            const yy = -h * 0.9 + u * h * 1.8;
            const bend = Math.sin((yy / (h * 1.8)) * Math.PI) * w * 0.05;
            const x = cx + bend;
            if (j === 0) ctx.moveTo(x, yy);
            else ctx.lineTo(x, yy);
          }
          ctx.stroke();
        }

        // zlatá mřížka – vodorovné "rovnoběžky"
        const rows = 5;
        for (let j = 0; j <= rows; j++) {
          const t = j / rows;
          const y = -h * 0.9 + t * h * 1.8;
          ctx.beginPath();
          for (let i = 0; i <= 40; i++) {
            const u = i / 40;
            const xx = -w * 0.9 + u * w * 1.8;
            const bulge = Math.cos((xx / (w * 1.8)) * Math.PI) * h * 0.12;
            const yy = y - bulge;
            if (i === 0) ctx.moveTo(xx, yy);
            else ctx.lineTo(xx, yy);
          }
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawCroissant() {
        const orbitR = baseSize * 2.1;
        const a = orbitAngle;
        const x3 = Math.cos(a) * orbitR;
        const z3 = Math.sin(a) * orbitR;
        const y3 = 0.3 * baseSize;

        const p = project3D(x3, y3, z3);

        ctx.save();
        ctx.translate(width / 2 + p.x, height / 2 + p.y);

        // natočení špičky směrem k prstenci
        ctx.rotate(a + Math.PI);
        ctx.scale(baseSize * 0.3, baseSize * 0.3);

        // jemný glow kolem
        ctx.save();
        ctx.shadowColor = "rgba(255, 220, 170, 0.7)";
        ctx.shadowBlur = 14;
        drawCroissantBody(1);
        ctx.restore();

        drawCroissantBody(1);

        ctx.restore();
      }

      // interakce
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      function pointerDown(e) {
        const t = e.touches ? e.touches[0] : e;
        isDragging = true;
        lastX = t.clientX;
        lastY = t.clientY;
      }

      function pointerMove(e) {
        if (!isDragging) return;
        const t = e.touches ? e.touches[0] : e;
        const dx = t.clientX - lastX;
        const dy = t.clientY - lastY;
        lastX = t.clientX;
        lastY = t.clientY;

        targetTiltY += dx * 0.005;
        targetTiltX += dy * 0.005;
      }

      function pointerUp() {
        isDragging = false;
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches && e.touches.length === 2) return;
          pointerMove(e);
        },
        { passive: false }
      );
      window.addEventListener("touchend", pointerUp);
      window.addEventListener("touchcancel", pointerUp);

      // zoom kolečkem
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          targetScale = Math.max(0.7, Math.min(2.5, targetScale * factor));
        },
        { passive: false }
      );

      // jednoduchý pinch zoom
      let pinchStart = null;
      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches && e.touches.length === 2) {
            e.preventDefault();
            const dx =
              e.touches[0].clientX - e.touches[1].clientX;
            const dy =
              e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            if (!pinchStart) pinchStart = dist;
            else {
              const ratio = dist / pinchStart;
              targetScale = Math.max(
                0.7,
                Math.min(2.5, targetScale * ratio)
              );
              pinchStart = dist;
            }
          } else {
            pinchStart = null;
          }
        },
        { passive: false }
      );

      // animace
      let lastTime = 0;
      function loop(ts) {
        if (!ts) ts = 0;
        const dt = (ts - lastTime) / 1000;
        lastTime = ts;

        const k = Math.min(1, dt * 6);
        viewScale += (targetScale - viewScale) * k;
        tiltX += (targetTiltX - tiltX) * k;
        tiltY += (targetTiltY - tiltY) * k;

        orbitAngle += dt * 0.4;

        ctx.clearRect(0, 0, width, height);
        drawFloor();
        drawRing();
        drawCroissant();

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
