<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T • Canvas Ring + Croissant</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #scene {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 16px;
        top: 12px;
        font-size: 11px;
        opacity: 0.8;
        background: rgba(5, 8, 20, 0.82);
        padding: 6px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="scene"></canvas>
        <div class="hud">
          Ring + croissant • prsty otáčej scénu (náklon) • pinch / kolečko = zoom
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("scene");
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;

      let width = 0;
      let height = 0;
      let baseSize = 1;

      // "kamera"
      let viewScale = 1.1;
      let targetScale = 1.1;
      let tiltX = -0.45;
      let tiltY = 0.4;
      let targetTiltX = tiltX;
      let targetTiltY = tiltY;

      let orbitAngle = 0;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        baseSize = Math.min(width, height) * 0.22;
      }

      window.addEventListener("resize", resize);
      resize();

      // pomocná projekce "pseud 3D" (jen náklon X/Y)
      function project3D(x, y, z) {
        // rotace kolem X
        let y1 = y * Math.cos(tiltX) - z * Math.sin(tiltX);
        let z1 = y * Math.sin(tiltX) + z * Math.cos(tiltX);
        // rotace kolem Y
        let x2 = x * Math.cos(tiltY) + z1 * Math.sin(tiltY);
        let z2 = -x * Math.sin(tiltY) + z1 * Math.cos(tiltY);

        return {
          x: x2 * viewScale,
          y: y1 * viewScale,
          z: z2,
        };
      }

      // --- PODLAHA GRID ---
      function drawFloor() {
        ctx.save();
        ctx.translate(width / 2, height / 2);

        const size = baseSize * 4;
        const step = baseSize * 0.4;

        ctx.strokeStyle = "rgba(90,110,180,0.4)";
        ctx.lineWidth = 0.6;

        for (let x = -size; x <= size; x += step) {
          const p1 = project3D(x, 0, -size);
          const p2 = project3D(x, 0, size);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y + baseSize * 1.2);
          ctx.lineTo(p2.x, p2.y + baseSize * 1.2);
          ctx.stroke();
        }

        for (let z = -size; z <= size; z += step) {
          const p1 = project3D(-size, 0, z);
          const p2 = project3D(size, 0, z);
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y + baseSize * 1.2);
          ctx.lineTo(p2.x, p2.y + baseSize * 1.2);
          ctx.stroke();
        }

        ctx.restore();
      }

      // --- PRSTENEC (v půdorysu kruh, v projekci elipsa) ---
      function drawRing() {
        ctx.save();
        ctx.translate(width / 2, height / 2);

        const rOuter = baseSize * 1.15;
        const rInner = baseSize * 0.55;

        // stín
        const pShadow = project3D(0, 0, 0);
        ctx.save();
        ctx.translate(pShadow.x, pShadow.y + baseSize * 1.05);
        ctx.scale(viewScale, viewScale * 0.35);
        const g = ctx.createRadialGradient(0, 0, rInner * 0.1, 0, 0, rOuter);
        g.addColorStop(0, "rgba(0,0,0,0.9)");
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(0, 0, rOuter, rOuter, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // samotný prstenec – nejdřív v lokálním systému, pak náklon
        const segments = 120;

        function ringPath(radius) {
          ctx.beginPath();
          for (let i = 0; i <= segments; i++) {
            const a = (i / segments) * Math.PI * 2;
            const x = Math.cos(a) * radius;
            const z = Math.sin(a) * radius;
            const p = project3D(x, 0, z);
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          }
          ctx.closePath();
        }

        // vnější
        ringPath(rOuter);
        const gradOuter = ctx.createLinearGradient(
          -rOuter,
          -rOuter,
          rOuter,
          rOuter
        );
        gradOuter.addColorStop(0, "#fdf9ff");
        gradOuter.addColorStop(0.4, "#f0e9ff");
        gradOuter.addColorStop(1, "#c7d4ff");
        ctx.fillStyle = gradOuter;
        ctx.fill();

        // vnitřní "díra" – vyříznout
        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        ringPath(rInner);
        ctx.fill();
        ctx.restore();

        // okraj
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = "rgba(40,80,150,0.8)";
        ringPath(rOuter);
        ctx.stroke();

        ctx.restore();
      }

      // --- CROISSANT (pečivo + zlatá mřížka) ---

      function drawCroissantBody(localScale = 1) {
        const w = 2.6 * localScale;
        const h = 1.2 * localScale;

        ctx.beginPath();
        // horní hrana
        ctx.moveTo(-w * 0.9, 0);
        ctx.quadraticCurveTo(-w * 0.45, -h * 1.0, 0, -h * 1.15);
        ctx.quadraticCurveTo(w * 0.45, -h * 1.0, w * 0.9, 0);
        // spodní hrana
        ctx.quadraticCurveTo(w * 0.45, h * 0.9, 0, h * 1.05);
        ctx.quadraticCurveTo(-w * 0.45, h * 0.9, -w * 0.9, 0);
        ctx.closePath();

        // výřez "uštípnutí" vpravo (jako na fotce)
        ctx.save();
        ctx.clip();

        ctx.fillStyle = "#1a130b";
        ctx.fill();

        // jemný světelný přechod
        const g = ctx.createLinearGradient(-w, -h * 1.3, w, h * 1.3);
        g.addColorStop(0, "#2a1b10");
        g.addColorStop(0.3, "#3b2414");
        g.addColorStop(0.7, "#1c120b");
        g.addColorStop(1, "#120c08");
        ctx.fillStyle = g;
        ctx.fill();

        ctx.restore();

        // obrys pečiva
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = "rgba(255, 210, 150, 0.95)";
        ctx.shadowColor = "rgba(0,0,0,0.9)";
        ctx.shadowBlur = 4;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // zlaté "vrásky" nahoře
        ctx.strokeStyle = "rgba(255, 220, 170, 0.9)";
        ctx.lineWidth = 1;

        const cuts = 5;
        for (let i = 0; i < cuts; i++) {
          const t = (i + 0.5) / cuts;
          const cx = -w * 0.55 + t * w * 1.1;
          ctx.beginPath();
          ctx.moveTo(cx - 0.25 * localScale, -0.25 * localScale);
          ctx.quadraticCurveTo(
            cx,
            -0.65 * localScale,
            cx + 0.25 * localScale,
            -0.25 * localScale
          );
          ctx.stroke();
        }

        // mřížka (vertikální + horizontální linky)
        ctx.lineWidth = 0.7;
        ctx.globalAlpha = 0.55;
        const cols = 8;
        const rows = 4;

        for (let i = 0; i <= cols; i++) {
          const t = i / cols;
          const x = -w * 0.9 + t * w * 1.8;
          ctx.beginPath();
          ctx.moveTo(x, -h * 0.7);
          ctx.lineTo(x, h * 0.7);
          ctx.stroke();
        }

        for (let j = 0; j <= rows; j++) {
          const t = j / rows;
          const y = -h * 0.8 + t * h * 1.6;
          ctx.beginPath();
          ctx.moveTo(-w * 0.9, y);
          ctx.lineTo(w * 0.9, y);
          ctx.stroke();
        }

        ctx.globalAlpha = 1;
      }

      function drawCroissant() {
        // pozice croissantu na "orbitu" kolem prstence
        const orbitR = baseSize * 2.1;
        const a = orbitAngle;
        const x3 = Math.cos(a) * orbitR;
        const z3 = Math.sin(a) * orbitR;
        const y3 = 0.3 * baseSize;

        const p = project3D(x3, y3, z3);

        ctx.save();
        ctx.translate(width / 2 + p.x, height / 2 + p.y);

        // natočení tak, aby "mířil" k prstenci
        ctx.rotate(a + Math.PI); // špička k prstenci
        ctx.scale(baseSize * 0.3, baseSize * 0.3);

        // jemný glow
        ctx.save();
        ctx.shadowColor = "rgba(255, 220, 170, 0.7)";
        ctx.shadowBlur = 12;
        drawCroissantBody(1);
        ctx.restore();

        drawCroissantBody(1);

        ctx.restore();
      }

      // --- OVLÁDÁNÍ DOTYK / MYŠ ---

      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      function pointerDown(e) {
        const t = e.touches ? e.touches[0] : e;
        isDragging = true;
        lastX = t.clientX;
        lastY = t.clientY;
      }

      function pointerMove(e) {
        if (!isDragging) return;
        const t = e.touches ? e.touches[0] : e;
        const dx = t.clientX - lastX;
        const dy = t.clientY - lastY;
        lastX = t.clientX;
        lastY = t.clientY;

        targetTiltY += dx * 0.005;
        targetTiltX += dy * 0.005;
      }

      function pointerUp() {
        isDragging = false;
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      window.addEventListener("touchmove", (e) => {
        if (e.touches && e.touches.length === 2) return; // pinch řeší wheel
        pointerMove(e);
      }, { passive: false });
      window.addEventListener("touchend", pointerUp);
      window.addEventListener("touchcancel", pointerUp);

      // zoom kolečkem
      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          targetScale = Math.max(0.7, Math.min(2.5, targetScale * factor));
        },
        { passive: false }
      );

      // jednoduchý pinch zoom (jen vzdálenost prstů)
      let pinchStart = null;
      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches && e.touches.length === 2) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            if (!pinchStart) pinchStart = dist;
            else {
              const ratio = dist / pinchStart;
              targetScale = Math.max(0.7, Math.min(2.5, targetScale * ratio));
              pinchStart = dist;
            }
          } else {
            pinchStart = null;
          }
        },
        { passive: false }
      );

      // --- ANIMACE ---
      let lastTime = 0;
      function loop(ts) {
        if (!ts) ts = 0;
        const dt = (ts - lastTime) / 1000;
        lastTime = ts;

        // plynulý přechod kamery
        const k = Math.min(1, dt * 6);
        viewScale += (targetScale - viewScale) * k;
        tiltX += (targetTiltX - tiltX) * k;
        tiltY += (targetTiltY - tiltY) * k;

        orbitAngle += dt * 0.4;

        ctx.clearRect(0, 0, width, height);

        drawFloor();
        drawRing();
        drawCroissant();

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
