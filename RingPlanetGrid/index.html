<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <title>VaF'i'T • Ring Planet Grid</title>

    <style>
      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      #app {
        position: fixed;
        inset: 0;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .hud {
        position: fixed;
        left: 12px;
        top: 12px;
        padding: 8px 12px;
        background: rgba(5, 8, 20, 0.85);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        max-width: min(80vw, 320px);
        font-size: 12px;
        line-height: 1.4;
      }

      .hud strong {
        font-size: 13px;
      }

      .hud-bottom {
        position: fixed;
        right: 12px;
        bottom: 12px;
        padding: 6px 10px;
        font-size: 11px;
        background: rgba(5, 8, 20, 0.85);
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        opacity: 0.9;
      }
    </style>

    <!-- JEN THREE.JS -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  </head>

  <body>
    <div id="app"></div>

    <div class="hud">
      <strong>Ring Planet Grid</strong><br />
      • prsty otáčej scénu<br />
      • dvěma prsty / kolečkem přibližuj / oddaluj<br />
      • prstenec = „plastelína“<br />
      • croissant = 3D pečivo ve zlaté mřížce
    </div>

    <div class="hud-bottom">
      ً&’」 • Vivere atque FruiT • RingPlanetGrid
    </div>

    <script>
      const app = document.getElementById("app");
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        300
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x020208, 1);
      renderer.outputEncoding = THREE.sRGBEncoding;
      app.appendChild(renderer.domElement);

      // SVĚTLO
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(12, 20, 10);
      scene.add(dirLight);

      // MŘÍŽKA
      const grid = new THREE.GridHelper(40, 40, 0x7f7fff, 0x222244);
      grid.position.y = -3;
      scene.add(grid);

      // NODY NA MŘÍŽCE
      const nodeGeom = new THREE.SphereGeometry(0.12, 12, 12);
      const nodeMat = new THREE.MeshBasicMaterial({ color: 0x7f9dff });
      const nodes = new THREE.Group();
      for (let x = -4; x <= 4; x += 2) {
        for (let z = -4; z <= 4; z += 2) {
          const n = new THREE.Mesh(nodeGeom, nodeMat);
          n.position.set(x, -2.95, z);
          nodes.add(n);
        }
      }
      scene.add(nodes);

      // HLAVNÍ PRSTENEC – PLASTELÍNA
      const mainRingGeom = new THREE.TorusGeometry(4, 1.1, 40, 140);
      const mainRingMat = new THREE.MeshStandardMaterial({
        color: 0xf5f3ff,
        metalness: 0.05,
        roughness: 0.6,
        emissive: 0x111111,
        emissiveIntensity: 0.2,
      });

      const mainRing = new THREE.Mesh(mainRingGeom, mainRingMat);
      mainRing.scale.set(1.7, 0.7, 1.1);
      mainRing.position.set(0, 0.8, 0);
      mainRing.rotation.x = Math.PI / 2.1;

      // drobná nepravidelnost povrchu
      {
        const pos = mainRing.geometry.attributes.position;
        const tmp = new THREE.Vector3();
        for (let i = 0; i < pos.count; i++) {
          tmp.fromBufferAttribute(pos, i);
          const noise =
            (Math.sin(tmp.x * 3.1) + Math.cos(tmp.z * 2.7)) * 0.03 +
            (Math.random() - 0.5) * 0.02;
          tmp.multiplyScalar(1 + noise);
          pos.setXYZ(i, tmp.x, tmp.y, tmp.z);
        }
        pos.needsUpdate = true;
        mainRing.geometry.computeVertexNormals();
      }
      scene.add(mainRing);

      // CROISSANT – 3D PEČIVO VE ZLATÉ MŘÍŽCE

      // cesta (ohnutý rohlík)
      const croissantPath = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-2.2, 0.0, 0.0),
        new THREE.Vector3(-1.1, 0.45, 0.1),
        new THREE.Vector3(0.0, 0.7, 0.0),
        new THREE.Vector3(1.1, 0.45, -0.1),
        new THREE.Vector3(2.2, 0.0, 0.0),
      ]);

      const croissantRadius = 0.55;
      const croissantGeom = new THREE.TubeGeometry(
        croissantPath,
        90, // délka segmentace
        croissantRadius,
        18, // kolik "hran" kolem
        false
      );

      // základní tělo (tmavší pečivo)
      const croissantBaseMat = new THREE.MeshStandardMaterial({
        color: 0x1b1309,
        metalness: 0.15,
        roughness: 0.85,
        emissive: 0x110700,
        emissiveIntensity: 0.35,
      });
      const croissantBase = new THREE.Mesh(croissantGeom, croissantBaseMat);

      // zlatá mřížka jako u 2D koulí
      const croissantWireGeom = new THREE.WireframeGeometry(croissantGeom);
      const croissantWireMat = new THREE.LineBasicMaterial({
        color: 0xffe4aa,
      });
      const croissantWire = new THREE.LineSegments(
        croissantWireGeom,
        croissantWireMat
      );

      const croissantBody = new THREE.Group();
      croissantBody.add(croissantBase);
      croissantBody.add(croissantWire);

      // tvar podobný fotce: mírně zploštit
      croissantBody.scale.set(0.95, 1.05, 0.9);
      croissantBody.rotation.x = Math.PI / 2; // položit na bok
      croissantBody.rotation.z = Math.PI * 0.1;

      // orbit kolem prstence
      const croissantOrbit = new THREE.Group();
      croissantBody.position.set(6.5, 0.8, 0);
      croissantOrbit.add(croissantBody);
      scene.add(croissantOrbit);

      // --- OVLÁDÁNÍ KAMERY (DRAG + ZOOM) ---
      const spherical = {
        radius: 18,
        phi: Math.PI / 3,
        theta: Math.PI / 4,
      };

      function updateCamera() {
        const r = spherical.radius;
        const sinPhi = Math.sin(spherical.phi);
        camera.position.x = r * sinPhi * Math.cos(spherical.theta);
        camera.position.y = r * Math.cos(spherical.phi);
        camera.position.z = r * sinPhi * Math.sin(spherical.theta);
        camera.lookAt(0, 0, 0);
      }
      updateCamera();

      let isDragging = false;
      let lastX = 0;
      let lastY = 0;

      function onPointerDown(e) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      }

      function onPointerMove(e) {
        if (!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;

        spherical.theta -= dx * 0.005;
        spherical.phi -= dy * 0.005;
        const eps = 0.15;
        spherical.phi = Math.max(eps, Math.min(Math.PI - eps, spherical.phi));

        updateCamera();
      }

      function onPointerUp() {
        isDragging = false;
      }

      renderer.domElement.addEventListener("pointerdown", onPointerDown);
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
      window.addEventListener("pointerleave", onPointerUp);

      // ZOOM – kolečko
      window.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 1.1 : 0.9;
          spherical.radius *= factor;
          spherical.radius = Math.max(6, Math.min(60, spherical.radius));
          updateCamera();
        },
        { passive: false }
      );

      // PINCH ZOOM – mobil
      let pinchStartDist = null;
      function distance(t1, t2) {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      renderer.domElement.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            pinchStartDist = distance(e.touches[0], e.touches[1]);
          }
        },
        { passive: false }
      );

      renderer.domElement.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length === 2 && pinchStartDist) {
            e.preventDefault();
            const d = distance(e.touches[0], e.touches[1]);
            const scale = pinchStartDist / d;
            spherical.radius *= scale;
            spherical.radius = Math.max(6, Math.min(60, spherical.radius));
            pinchStartDist = d;
            updateCamera();
          }
        },
        { passive: false }
      );

      renderer.domElement.addEventListener("touchend", () => {
        pinchStartDist = null;
      });

      // RESIZE
      window.addEventListener("resize", () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });

      // ANIMACE
      let t = 0;
      function animate() {
        requestAnimationFrame(animate);
        t += 0.01;

        nodes.rotation.y += 0.001;
        mainRing.rotation.z = Math.sin(t * 0.4) * 0.06;

        croissantOrbit.rotation.y += 0.01;
        croissantBase.material.emissiveIntensity =
          0.3 + 0.15 * Math.sin(t * 2.0);

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
