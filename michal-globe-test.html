<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Michal Klimek VaF'i'T ChatGPT ‚Ä¢ koule svƒõta</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none; /* vlastn√≠ gesta, ne scroll str√°nky */
      }

      .stage {
        position: relative;
        width: min(520px, 80vw);
        height: min(520px, 80vw);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.04);
        transform-origin: center center;
        will-change: transform;
      }

      #globe-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .toast {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        padding: 6px 14px;
        border-radius: 999px;
        background: rgba(8, 8, 9, 0.86);
        border: 1px solid rgba(255, 220, 150, 0.6);
        font-size: 11px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        white-space: nowrap;
      }

      .toast.show {
        opacity: 1;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="globe-canvas"></canvas>

        <div class="hud">
          üåÄ ot√°ƒçej kouli prstem / my≈°√≠ &nbsp;‚Ä¢&nbsp;
          dvƒõma prsty posouvej / p≈ôibli≈æuj
        </div>
        <div class="hud-right">v0.3 ‚Ä¢ koule svƒõta</div>
      </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
      // === Z√ÅKLADN√ç NASTAVEN√ç CANVAS / KOULE ===
      const canvas = document.getElementById("globe-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      let cx = 0;
      let cy = 0;
      let radius = 0;
      let dpr = window.devicePixelRatio || 1;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        cx = width / 2;
        cy = height / 2;
        radius = Math.min(width, height) * 0.33;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      resize();
      window.addEventListener("resize", resize);

      // stav ot√°ƒçen√≠
      let rotY = 0.5;
      let rotX = -0.3;

      // === PROJEKCE 3D ‚Üí 2D ===
      function project(x, y, z) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        const scale = radius * 0.9;
        return {
          x: cx + x2 * scale,
          y: cy + y1 * scale,
          z: z2,
        };
      }

      // === DEFINICE SLOT≈Æ NA KOULE (lat / lon) ===
      const slots = [];
      const slotRows = 7; // p√°sy
      const slotCols = 10; // kolem dokola ‚Üí cca 70 slot≈Ø

      // lat od -60¬∞ do +60¬∞
      for (let i = 0; i < slotRows; i++) {
        const lat =
          ((i + 0.5) / slotRows) * (Math.PI * (2 / 3)) - Math.PI / 3; // -60¬∞..+60¬∞
        for (let j = 0; j < slotCols; j++) {
          const lon = (j / slotCols) * Math.PI * 2;

          slots.push({
            lat,
            lon,
            label: "slot " + (slots.length + 1),
            href: null,
            screenX: 0,
            screenY: 0,
            visible: false,
          });
        }
      }

      // p√°r pojmenovan√Ωch slot≈Ø (m≈Ø≈æe≈° si p≈ôepsat / p≈ôidat href)
      if (slots[34]) {
        slots[34].label = "MK";
        slots[34].href = "./Michal-AI-Al-Klimek/index.html";
      }
      if (slots[35]) {
        slots[35].label = "VaF'i'T";
        slots[35].href = "./VaFiT/index.html";
      }
      if (slots[36]) {
        slots[36].label = "Revia";
        slots[36].href = "./Revia/index.html";
      }

      // === KRESLEN√ç KOULE ===
      function drawGlobe() {
        ctx.clearRect(0, 0, width, height);

        // jemn√Ω podklad
        const g = ctx.createRadialGradient(
          cx,
          cy - radius * 0.4,
          radius * 0.2,
          cx,
          cy,
          radius * 1.4
        );
        g.addColorStop(0, "rgba(255, 200, 150, 0.18)");
        g.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);

        // st√≠nov√° koule
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 1.02, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fill();

        // z√°kladn√≠ tƒõlo koule
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        const globeGrad = ctx.createRadialGradient(
          cx - radius * 0.3,
          cy - radius * 0.4,
          radius * 0.3,
          cx,
          cy + radius * 0.4,
          radius * 1.1
        );
        globeGrad.addColorStop(0, "#2d1d0f");
        globeGrad.addColorStop(0.5, "#1b1012");
        globeGrad.addColorStop(1, "#050308");
        ctx.fillStyle = globeGrad;
        ctx.fill();

        // zlat√Ω okraj
        ctx.strokeStyle = "rgba(255, 197, 120, 0.9)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // m≈ô√≠≈æka ‚Äì zlat√© linky
        ctx.lineWidth = 0.85;
        ctx.strokeStyle = "rgba(255, 210, 140, 0.8)";

        // pod√©ln√© kru≈ænice (meridi√°ny)
        const meridians = 12;
        for (let i = 0; i < meridians; i++) {
          const lon = (i / meridians) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 60; s++) {
            const t = (s / 60) * Math.PI - Math.PI / 2;
            const x = Math.cos(t) * Math.cos(lon);
            const y = Math.sin(t);
            const z = Math.cos(t) * Math.sin(lon);
            const p = project(x, y, z);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        // rovnobƒõ≈æky (paralely)
        const parallels = 8;
        for (let j = 1; j < parallels; j++) {
          const lat = (j / parallels) * Math.PI - Math.PI / 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 90; s++) {
            const lon = (s / 90) * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            const p = project(x, y, z);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        // === TEXT UVNIT≈ò KOULE (na p√°sku) ===
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotY * 0.25);

        ctx.font = "700 16px system-ui";
        ctx.fillStyle = "rgba(255, 220, 150, 0.95)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(255, 200, 120, 0.9)";
        ctx.shadowBlur = 14;

        const text = "{*(¬∞.).)// Vivere atque Fru'ii'T \\\\(.(.¬∞)*]";
        ctx.fillText(text, 0, 0);

        ctx.restore();
        ctx.shadowBlur = 0;

        // === SLOT TLAƒå√çTKA ===
        ctx.font = "600 9px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (const slot of slots) {
          const x3 = Math.cos(slot.lat) * Math.cos(slot.lon);
          const y3 = Math.sin(slot.lat);
          const z3 = Math.cos(slot.lat) * Math.sin(slot.lon);
          const p = project(x3, y3, z3);

          if (p.z <= 0) {
            slot.visible = false;
            continue;
          }

          slot.visible = true;
          slot.screenX = p.x;
          slot.screenY = p.y;

          const w = 46;
          const h = 18;
          const r = 6;

          // destiƒçka
          ctx.beginPath();
          roundedRect(ctx, p.x - w / 2, p.y - h / 2, w, h, r);
          ctx.fillStyle = "rgba(6, 6, 10, 0.95)";
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 220, 160, 0.85)";
          ctx.lineWidth = 0.9;
          ctx.stroke();

          // label
          ctx.fillStyle = "rgba(255, 235, 190, 0.98)";
          ctx.fillText(slot.label, p.x, p.y + 0.5);
        }
      }

      function roundedRect(ctx, x, y, w, h, r) {
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
      }

      // === HLADK√ù LOOP ===
      let lastTime = 0;

      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        rotY += 0.4 * dt;
        drawGlobe();

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      // === KLIK√ÅN√ç NA SLOTY ===
      function pickSlotAt(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        let closest = null;
        let bestDist = Infinity;

        for (const slot of slots) {
          if (!slot.visible) continue;
          const dx = x - slot.screenX;
          const dy = y - slot.screenY;
          const d2 = dx * dx + dy * dy;
          if (d2 < 900 && d2 < bestDist) {
            // 30px radius
            bestDist = d2;
            closest = slot;
          }
        }
        return closest;
      }

      canvas.addEventListener("click", (e) => {
        const slot = pickSlotAt(e.clientX, e.clientY);
        if (!slot) return;

        if (slot.href) {
          showToast("Otev√≠r√°m svƒõt: " + slot.label);
          window.location.href = slot.href;
        } else {
          showToast(
            "Slot: " +
              slot.label +
              " ‚Ä¢ zat√≠m bez odkazu ‚Äì dopln√≠me do href v indexu."
          );
        }
      });

      // === TOAST ZPR√ÅVY ===
      const toastEl = document.getElementById("toast");
      let toastTimeout = null;

      function showToast(text) {
        toastEl.textContent = text;
        toastEl.classList.add("show");
        if (toastTimeout) clearTimeout(toastTimeout);
        toastTimeout = setTimeout(() => {
          toastEl.classList.remove("show");
        }, 2200);
      }

      // === ROTACE KOULE JEDN√çM PRSTEM / MY≈†√ç ===
      let drag = false;
      let lastX = 0;
      let lastY = 0;

      function pointerDownRotate(e) {
        // pokud zrovna pou≈æ√≠v√°me dvouprst√© gesto pro zoom/pan, neot√°ƒç√≠me
        if (e.touches && e.touches.length > 1) return;

        drag = true;
        const touch = e.touches ? e.touches[0] : e;
        lastX = touch.clientX;
        lastY = touch.clientY;
      }

      function pointerMoveRotate(e) {
        if (!drag) return;
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX;
        const y = touch.clientY;
        const dx = x - lastX;
        const dy = y - lastY;
        lastX = x;
        lastY = y;

        rotY += dx * 0.004;
        rotX += dy * 0.004;
        rotX = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, rotX));
      }

      function pointerUpRotate() {
        drag = false;
      }

      canvas.addEventListener("mousedown", pointerDownRotate);
      window.addEventListener("mousemove", pointerMoveRotate);
      window.addEventListener("mouseup", pointerUpRotate);

      canvas.addEventListener("touchstart", pointerDownRotate, {
        passive: true,
      });
      window.addEventListener("touchmove", pointerMoveRotate, {
        passive: true,
      });
      window.addEventListener("touchend", pointerUpRotate);

      // === ZOOM + POSUN CEL√â KOULE (STAGE) ===
      const stage = document.querySelector(".stage");
      let viewScale = 1;
      let viewX = 0;
      let viewY = 0;

      function applyViewTransform() {
        stage.style.transform = `translate(${viewX}px, ${viewY}px) scale(${viewScale})`;
      }
      applyViewTransform();

      // zoom koleƒçkem my≈°i
      document.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY < 0 ? 1.05 : 0.95;
          const prevScale = viewScale;
          viewScale *= factor;
          viewScale = Math.max(0.4, Math.min(3, viewScale));

          // zoom kolem st≈ôedu obrazovky
          const rect = stage.getBoundingClientRect();
          const cxLocal = e.clientX - (rect.left + rect.width / 2);
          const cyLocal = e.clientY - (rect.top + rect.height / 2);
          const k = viewScale / prevScale - 1;
          viewX -= cxLocal * k;
          viewY -= cyLocal * k;

          applyViewTransform();
        },
        { passive: false }
      );

      // pan my≈°√≠ ‚Äì prav√© nebo prost≈ôedn√≠ tlaƒç√≠tko
      let panMouse = false;
      let panLastX = 0;
      let panLastY = 0;

      document.addEventListener("mousedown", (e) => {
        if (e.button === 1 || e.button === 2) {
          panMouse = true;
          panLastX = e.clientX;
          panLastY = e.clientY;
          e.preventDefault();
        }
      });

      document.addEventListener("mousemove", (e) => {
        if (!panMouse) return;
        const dx = e.clientX - panLastX;
        const dy = e.clientY - panLastY;
        panLastX = e.clientX;
        panLastY = e.clientY;
        viewX += dx;
        viewY += dy;
        applyViewTransform();
      });

      document.addEventListener("mouseup", () => {
        panMouse = false;
      });

      // touch ‚Äì dvouprst√© pinch+pan
      let touchMode = null; // 'view' nebo null
      let startDist = 0;
      let startScale = 1;
      let startViewX = 0;
      let startViewY = 0;
      let startMidX = 0;
      let startMidY = 0;

      function dist(t1, t2) {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.hypot(dx, dy);
      }

      function mid(t1, t2) {
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2,
        };
      }

      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            // p≈ôeb√≠r√°me gesto pro zoom/pan, zastav√≠me ot√°ƒçen√≠
            e.preventDefault();
            touchMode = "view";
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            startDist = dist(t1, t2);
            const m = mid(t1, t2);
            startMidX = m.x;
            startMidY = m.y;
            startScale = viewScale;
            startViewX = viewX;
            startViewY = viewY;
          }
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchmove",
        (e) => {
          if (touchMode !== "view" || e.touches.length !== 2) return;
          e.preventDefault();
          const t1 = e.touches[0];
          const t2 = e.touches[1];

          const newDist = dist(t1, t2);
          const m = mid(t1, t2);

          const scaleFactor = newDist / (startDist || newDist);
          viewScale = Math.max(0.4, Math.min(3, startScale * scaleFactor));

          viewX = startViewX + (m.x - startMidX);
          viewY = startViewY + (m.y - startMidY);

          applyViewTransform();
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchend",
        (e) => {
          if (e.touches.length < 2) {
            touchMode = null;
          }
        },
        { passive: false }
      );
    </script>
  </body>
</html>
