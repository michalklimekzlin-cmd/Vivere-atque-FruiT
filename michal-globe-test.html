<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Michal Klimek VaF'i'T ChatGPT</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(520px, 80vw);
        height: min(520px, 80vw);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      #globe-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.7;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="globe-canvas"></canvas>

        <div class="hud">üåÄ ot√°ƒçej kouli prstem / my≈°√≠ ‚Ä¢ ≈•ukni na destiƒçku pro n√°zev svƒõta</div>
        <div class="hud-right">v0.3 ‚Ä¢ koule se svƒõty</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("globe-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      let cx = 0;
      let cy = 0;
      let radius = 0;
      let dpr = window.devicePixelRatio || 1;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        cx = width / 2;
        cy = height / 2;
        radius = Math.min(width, height) * 0.33;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      resize();
      window.addEventListener("resize", resize);

      // stav ot√°ƒçen√≠
      let rotY = 0.5;
      let rotX = -0.3;
      let drag = false;
      let dragMoved = false;
      let lastX = 0;
      let lastY = 0;

      // === definice destiƒçek (70 ks ‚Äì 5 ≈ôad √ó 14 sloupc≈Ø) ===
      const latBands = 5;
      const lonBands = 14;
      const tiles = []; // trval√° data (lat/lon + label/link)
      const visibleTiles = []; // p≈ôepoƒç√≠tan√© pro aktu√°ln√≠ frame (projekce)

      (function initTiles() {
        const latMargin = 0.4; // nezasahujeme √∫plnƒõ k p√≥l≈Øm
        const latStep = (Math.PI - 2 * latMargin) / latBands;

        let id = 0;
        for (let i = 0; i < latBands; i++) {
          const lat0 = -Math.PI / 2 + latMargin + i * latStep;
          const lat1 = lat0 + latStep;

          for (let j = 0; j < lonBands; j++) {
            const lon0 = (j / lonBands) * Math.PI * 2;
            const lon1 = ((j + 1) / lonBands) * Math.PI * 2;

            tiles.push({
              id,
              lat0,
              lat1,
              lon0,
              lon1,
              label: "",
              link: ""
            });

            id++;
          }
        }

        // p≈ôedvypln√≠me dva svƒõty nƒõkde kolem "p≈ôedku" koule
        const midBand = Math.floor(latBands / 2); // prost≈ôedn√≠ p√°s
        const centerCol = Math.floor(lonBands / 2);

        const idxVaft = midBand * lonBands + centerCol;
        const idxRevia = midBand * lonBands + centerCol + 1;

        if (tiles[idxVaft]) tiles[idxVaft].label = "VaF'i'T";
        if (tiles[idxRevia]) tiles[idxRevia].label = "Revia";

        loadTilesState();
      })();

      function saveTilesState() {
        try {
          const minimal = tiles.map((t) => ({ id: t.id, label: t.label, link: t.link }));
          localStorage.setItem("vaft_globe_tiles_v1", JSON.stringify(minimal));
        } catch (e) {
          // nic, jenom fallback ‚Äì na nƒõkter√Ωch prohl√≠≈æeƒç√≠ch nemus√≠ proj√≠t
        }
      }

      function loadTilesState() {
        try {
          const raw = localStorage.getItem("vaft_globe_tiles_v1");
          if (!raw) return;
          const parsed = JSON.parse(raw);
          const byId = new Map(parsed.map((t) => [t.id, t]));
          tiles.forEach((t) => {
            const saved = byId.get(t.id);
            if (saved) {
              t.label = saved.label || "";
              t.link = saved.link || "";
            }
          });
        } catch (e) {
          // ignorujeme
        }
      }

      // projekce 3D ‚Üí 2D
      function project(x, y, z) {
        // rotace kolem osy X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

        // rotace kolem osy Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        const scale = radius * 0.9;
        return {
          x: cx + x2 * scale,
          y: cy + y1 * scale,
          z: z2
        };
      }

      function drawGlobe() {
        ctx.clearRect(0, 0, width, height);

        // jemn√Ω podklad
        const g = ctx.createRadialGradient(
          cx,
          cy - radius * 0.4,
          radius * 0.2,
          cx,
          cy,
          radius * 1.4
        );
        g.addColorStop(0, "rgba(255, 200, 150, 0.18)");
        g.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);

        // st√≠nov√° koule
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 1.02, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fill();

        // z√°kladn√≠ tƒõlo koule
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        const globeGrad = ctx.createRadialGradient(
          cx - radius * 0.3,
          cy - radius * 0.4,
          radius * 0.3,
          cx,
          cy + radius * 0.4,
          radius * 1.1
        );
        globeGrad.addColorStop(0, "#2d1d0f");
        globeGrad.addColorStop(0.5, "#1b1012");
        globeGrad.addColorStop(1, "#050308");
        ctx.fillStyle = globeGrad;
        ctx.fill();

        // zlat√Ω okraj
        ctx.strokeStyle = "rgba(255, 197, 120, 0.9)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // m≈ô√≠≈æka ‚Äì zlat√© linky (jen jako atmosf√©ra)
        ctx.lineWidth = 0.8;
        ctx.strokeStyle = "rgba(255, 210, 140, 0.45)";

        const meridians = 12;
        for (let i = 0; i < meridians; i++) {
          const lon = (i / meridians) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 60; s++) {
            const t = (s / 60) * Math.PI - Math.PI / 2;
            const x = Math.cos(t) * Math.cos(lon);
            const y = Math.sin(t);
            const z = Math.cos(t) * Math.sin(lon);
            const p = project(x, y, z);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        const parallels = 8;
        for (let j = 1; j < parallels; j++) {
          const lat = (j / parallels) * Math.PI - Math.PI / 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 90; s++) {
            const lon = (s / 90) * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            const p = project(x, y, z);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        // === text uvnit≈ô koule (na p√°su) ===
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rotY * 0.15);
        ctx.font = "700 16px system-ui";
        ctx.fillStyle = "rgba(255, 220, 150, 0.95)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(255, 200, 120, 0.9)";
        ctx.shadowBlur = 14;
        ctx.fillText(
          "{*(¬∞.).)// Vivere atque Fru'ii'T \\\\(.(.¬∞)*]",
          0,
          0
        );
        ctx.restore();

        // === destiƒçky svƒõt≈Ø ===
        visibleTiles.length = 0;

        ctx.lineWidth = 1.0;
        ctx.shadowBlur = 0;

        for (const tile of tiles) {
          const { lat0, lat1, lon0, lon1 } = tile;

          // 4 rohy destiƒçky
          const corners3D = [
            [lat0, lon0],
            [lat0, lon1],
            [lat1, lon1],
            [lat1, lon0]
          ].map(([lat, lon]) => {
            const cl = Math.cos(lat);
            const x = cl * Math.cos(lon);
            const y = Math.sin(lat);
            const z = cl * Math.sin(lon);
            return project(x, y, z);
          });

          // pr≈Ømƒõrn√° Z ‚Äì zda je destiƒçka p≈ôed kamerou
          const avgZ =
            (corners3D[0].z +
              corners3D[1].z +
              corners3D[2].z +
              corners3D[3].z) /
            4;
          if (avgZ < 0) continue;

          // tvar destiƒçky
          ctx.beginPath();
          ctx.moveTo(corners3D[0].x, corners3D[0].y);
          for (let i = 1; i < corners3D.length; i++) {
            ctx.lineTo(corners3D[i].x, corners3D[i].y);
          }
          ctx.closePath();

          // lehk√© podbarven√≠
          ctx.fillStyle = "rgba(12, 8, 4, 0.32)";
          ctx.fill();

          // r√°meƒçek
          ctx.strokeStyle = "rgba(255, 230, 190, 0.8)";
          ctx.stroke();

          // st≈ôed destiƒçky pro label a hitbox
          const midLat = (lat0 + lat1) / 2;
          const midLon = (lon0 + lon1) / 2;
          const cl = Math.cos(midLat);
          const cx3d = project(
            cl * Math.cos(midLon),
            Math.sin(midLat),
            cl * Math.sin(midLon)
          );

          let label = tile.label;
          if (label) {
            ctx.font = "600 9px system-ui";
            ctx.fillStyle = "rgba(255, 235, 210, 0.95)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(0,0,0,0.7)";
            ctx.shadowBlur = 6;
            ctx.fillText(label, cx3d.x, cx3d.y);
            ctx.shadowBlur = 0;
          }

          visibleTiles.push({
            id: tile.id,
            corners: corners3D,
            center: { x: cx3d.x, y: cx3d.y }
          });
        }
      }

      // plynul√© ot√°ƒçen√≠ podle ƒçasu
      let lastTime = 0;

      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        rotY += 0.4 * dt; // vlastn√≠ ot√°ƒçen√≠
        drawGlobe();

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      // najde destiƒçku podle bodu v pl√°tnƒõ
      function findTileAt(x, y) {
        for (let i = visibleTiles.length - 1; i >= 0; i--) {
          const tile = visibleTiles[i];
          const poly = tile.corners;
          ctx.beginPath();
          ctx.moveTo(poly[0].x, poly[0].y);
          for (let j = 1; j < poly.length; j++) {
            ctx.lineTo(poly[j].x, poly[j].y);
          }
          ctx.closePath();
          if (ctx.isPointInPath(x, y)) {
            return tiles.find((t) => t.id === tile.id) || null;
          }
        }
        return null;
      }

      function handleTap(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left);
        const y = (clientY - rect.top);

        const tile = findTileAt(x, y);
        if (!tile) return;

        const currentName = tile.label || "";
        const name = window.prompt(
          "N√°zev svƒõta v t√©to destiƒçce:",
          currentName
        );
        if (name === null) return;

        tile.label = name.trim();
        saveTilesState();
      }

      // ovl√°d√°n√≠ prstem / my≈°√≠
      function pointerDown(e) {
        drag = true;
        dragMoved = false;
        const touch = e.touches ? e.touches[0] : e;
        lastX = touch.clientX;
        lastY = touch.clientY;
      }

      function pointerMove(e) {
        if (!drag) return;
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX;
        const y = touch.clientY;
        const dx = x - lastX;
        const dy = y - lastY;

        if (Math.abs(dx) + Math.abs(dy) > 3) {
          dragMoved = true;
        }

        lastX = x;
        lastY = y;

        rotY += dx * 0.004;
        rotX += dy * 0.004;
        rotX = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, rotX));
      }

      function pointerUp(e) {
        if (!drag) return;
        drag = false;

        const touch = e.changedTouches ? e.changedTouches[0] : e;
        if (!dragMoved) {
          // kr√°tk√© ≈•uknut√≠ = editace destiƒçky
          handleTap(touch.clientX, touch.clientY);
        }
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: true });
      window.addEventListener("touchmove", pointerMove, { passive: true });
      window.addEventListener("touchend", pointerUp);
    </script>
  </body>
</html>
