<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Michal Klimek VaF'i'T ChatGPT ‚Ä¢ 4 koule svƒõta</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(960px, 96vw);
        height: min(640px, 82vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #globe-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none; /* vlastn√≠ gesta */
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.7;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.7;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="globe-canvas"></canvas>

        <div class="hud">
          üåÄ ≈•ukej na kouli ‚Üí ta je aktivn√≠ ‚Ä¢ jedn√≠m prstem ot√°ƒçej ‚Ä¢ dvƒõma prsty
          posouvej &amp; zoomuj aktivn√≠ kouli ‚Ä¢ klepni na destiƒçku pro svƒõt
        </div>
        <div class="hud-right">v0.4 ‚Ä¢ 4√ó koule svƒõta</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("globe-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      let baseRadius = 0;
      const dpr = window.devicePixelRatio || 1;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        baseRadius = Math.min(width, height) * 0.18; // men≈°√≠ z√°klad, aby se 4 ve≈°ly
      }

      resize();
      window.addEventListener("resize", resize);

      // ---- GLOBE ENGINE ----

      function createSlots() {
        const slots = [];
        const bands = 7;
        const segs = 10;
        let id = 1;
        for (let b = 0; b < bands; b++) {
          const t = (b + 0.5) / bands; // -60¬∞ .. 60¬∞
          const lat = -Math.PI / 3 + t * ((2 * Math.PI) / 3);
          for (let s = 0; s < segs; s++) {
            const lon = (s / segs) * Math.PI * 2;
            slots.push({
              id,
              lat,
              lon,
              label: "slot " + id,
              localX: 0,
              localY: 0,
            });
            id++;
          }
        }

        // p√°r pojmenovan√Ωch slot≈Ø
        if (slots[34]) slots[34].label = "VaF'i'T";
        if (slots[35]) slots[35].label = "Revia";
        if (slots[36]) slots[36].label = "MK AI";

        return slots;
      }

      function makeGlobe(config) {
        return {
          id: config.id,
          // pozice koule na sc√©nƒõ (v pixelech od st≈ôedu stage)
          centerX: config.centerX,
          centerY: config.centerY,
          radiusScale: config.radiusScale ?? 1,

          // stav rotace
          rotX: config.rotX ?? -0.2,
          rotY: config.rotY ?? 0.5,
          autoSpin: config.autoSpin ?? 0.25,

          // zoom a drobn√Ω posun v r√°mci vlastn√≠ koule
          viewScale: 1,
          viewOffsetX: 0,
          viewOffsetY: 0,

          // interakce
          dragMode: "rotate", // "rotate" | "pan"
          drag: false,
          lastX: 0,
          lastY: 0,
          lastPanDist: 0,
          movedDistance: 0,

          // sloty
          slots: createSlots(),
        };
      }

      const globes = [
        makeGlobe({ id: "A", centerX: -220, centerY: -120, autoSpin: 0.22 }),
        makeGlobe({ id: "B", centerX: 220, centerY: -120, autoSpin: 0.26 }),
        makeGlobe({ id: "C", centerX: -220, centerY: 140, autoSpin: 0.20 }),
        makeGlobe({ id: "D", centerX: 220, centerY: 140, autoSpin: 0.30 }),
      ];

      let activeGlobe = globes[0];

      function project(globe, x, y, z, radius) {
        let y1 = y * Math.cos(globe.rotX) - z * Math.sin(globe.rotX);
        let z1 = y * Math.sin(globe.rotX) + z * Math.cos(globe.rotX);

        let x2 = x * Math.cos(globe.rotY) + z1 * Math.sin(globe.rotY);
        let z2 = -x * Math.sin(globe.rotY) + z1 * Math.cos(globe.rotY);

        const scale = radius * 0.9;
        return {
          x: x2 * scale,
          y: y1 * scale,
          z: z2,
        };
      }

      function drawSingleGlobe(globe) {
        const radius = baseRadius * globe.radiusScale;

        ctx.save();
        ctx.translate(
          width / 2 + globe.centerX + globe.viewOffsetX,
          height / 2 + globe.centerY + globe.viewOffsetY
        );
        ctx.scale(globe.viewScale, globe.viewScale);

        // glow
        const g = ctx.createRadialGradient(
          0,
          -radius * 0.4,
          radius * 0.2,
          0,
          0,
          radius * 1.4
        );
        g.addColorStop(0, "rgba(255, 200, 150, 0.18)");
        g.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = g;
        ctx.fillRect(-radius * 3, -radius * 3, radius * 6, radius * 6);

        // shadow
        ctx.beginPath();
        ctx.arc(0, 0, radius * 1.02, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fill();

        // tƒõlo
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        const globeGrad = ctx.createRadialGradient(
          -radius * 0.3,
          -radius * 0.4,
          radius * 0.3,
          0,
          radius * 0.4,
          radius * 1.1
        );
        globeGrad.addColorStop(0, "#2d1d0f");
        globeGrad.addColorStop(0.5, "#1b1012");
        globeGrad.addColorStop(1, "#050308");
        ctx.fillStyle = globeGrad;
        ctx.fill();

        // okraj
        ctx.strokeStyle =
          activeGlobe === globe
            ? "rgba(255, 230, 170, 0.95)"
            : "rgba(255, 197, 120, 0.9)";
        ctx.lineWidth = activeGlobe === globe ? 2.1 : 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // m≈ô√≠≈æka
        ctx.lineWidth = 0.8;
        ctx.strokeStyle = "rgba(255, 210, 140, 0.9)";

        const meridians = 12;
        for (let i = 0; i < meridians; i++) {
          const lon = (i / meridians) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 60; s++) {
            const t = (s / 60) * Math.PI - Math.PI / 2;
            const x = Math.cos(t) * Math.cos(lon);
            const y = Math.sin(t);
            const z = Math.cos(t) * Math.sin(lon);
            const p = project(globe, x, y, z, radius);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        const parallels = 8;
        for (let j = 1; j < parallels; j++) {
          const lat = (j / parallels) * Math.PI - Math.PI / 2;
          ctx.beginPath();
          let started = false;
          for (let s = 0; s <= 90; s++) {
            const lon = (s / 90) * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            const p = project(globe, x, y, z, radius);
            if (p.z >= 0) {
              if (!started) {
                ctx.moveTo(p.x, p.y);
                started = true;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }
          ctx.stroke();
        }

        // text uvnit≈ô
        ctx.save();
        ctx.font = "700 12px system-ui";
        ctx.fillStyle = "rgba(255, 220, 150, 0.95)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(255, 200, 120, 0.9)";
        ctx.shadowBlur = 12;
        ctx.rotate(0.9);
        ctx.fillText("{*(¬∞.).)// Vivere atque Fru'ii'T \\\\(.(.¬∞)*]", 0, 0);
        ctx.restore();

        // sloty
        const slotW = (radius * 0.35) / 3;
        const slotH = slotW * 0.65;

        ctx.font = "9px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (const slot of globe.slots) {
          const x = Math.cos(slot.lat) * Math.cos(slot.lon);
          const y = Math.sin(slot.lat);
          const z = Math.cos(slot.lat) * Math.sin(slot.lon);
          const p = project(globe, x, y, z, radius);
          if (p.z < 0) continue;

          slot.localX = p.x;
          slot.localY = p.y;

          ctx.save();
          ctx.translate(p.x, p.y);

          ctx.beginPath();
          const r = 5;
          const w = slotW;
          const h = slotH;
          ctx.moveTo(-w / 2 + r, -h / 2);
          ctx.lineTo(w / 2 - r, -h / 2);
          ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + r);
          ctx.lineTo(w / 2, h / 2 - r);
          ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - r, h / 2);
          ctx.lineTo(-w / 2 + r, h / 2);
          ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - r);
          ctx.lineTo(-w / 2, -h / 2 + r);
          ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + r, -h / 2);
          ctx.closePath();

          ctx.fillStyle = "rgba(6,6,10,0.92)";
          ctx.strokeStyle = "rgba(255,210,150,0.9)";
          ctx.lineWidth = 0.8;
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = "rgba(255,220,160,0.95)";
          ctx.shadowColor = "rgba(255,200,140,0.5)";
          ctx.shadowBlur = 5;
          ctx.fillText(slot.label, 0, 1);

          ctx.restore();
        }

        // label koule (A,B,C,D)
        ctx.save();
        ctx.font = "10px system-ui";
        ctx.fillStyle = "rgba(255,230,180,0.9)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.9)";
        ctx.shadowBlur = 10;
        ctx.fillText(globe.id, 0, -radius - 14);
        ctx.restore();

        ctx.restore();
      }

      function drawScene() {
        ctx.clearRect(0, 0, width, height);

        for (const globe of globes) {
          drawSingleGlobe(globe);
        }
      }

      // animace
      let lastTime = 0;
      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        for (const globe of globes) {
          if (!globe.drag || globe.dragMode === "pan") {
            globe.rotY += globe.autoSpin * dt;
          }
        }

        drawScene();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---- INTERAKCE ----

      function screenToGlobeLocal(globe, clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const sx = clientX - rect.left - width / 2;
        const sy = clientY - rect.top - height / 2;

        const x =
          (sx - globe.centerX - globe.viewOffsetX) / globe.viewScale;
        const y =
          (sy - globe.centerY - globe.viewOffsetY) / globe.viewScale;

        return { x, y };
      }

      function pickGlobe(clientX, clientY) {
        // vybere kouli, jej√≠m≈æ st≈ôedu je pointer nejbl√≠≈æ
        let best = null;
        let bestDist = Infinity;
        for (const globe of globes) {
          const rect = canvas.getBoundingClientRect();
          const sx = clientX - rect.left - width / 2;
          const sy = clientY - rect.top - height / 2;
          const gx = sx - globe.centerX - globe.viewOffsetX;
          const gy = sy - globe.centerY - globe.viewOffsetY;
          const dist = Math.hypot(gx, gy);
          const radius = baseRadius * globe.radiusScale * globe.viewScale;
          if (dist <= radius * 1.1 && dist < bestDist) {
            best = globe;
            bestDist = dist;
          }
        }
        return best;
      }

      let globalDrag = false;
      let globalDragMode = "rotate";
      let globalLastX = 0;
      let globalLastY = 0;
      let globalLastPanDist = 0;
      let globalMoved = 0;
      let pinchMode = false;

      function pointerDown(e) {
        e.preventDefault();

        if (e.touches && e.touches.length === 2) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const cxNow = (t0.clientX + t1.clientX) / 2;
          const cyNow = (t0.clientY + t1.clientY) / 2;

          const g = pickGlobe(cxNow, cyNow);
          if (!g) return;
          activeGlobe = g;

          pinchMode = true;
          globalDrag = true;
          globalDragMode = "pan";
          globalLastX = cxNow;
          globalLastY = cyNow;
          const dx = t0.clientX - t1.clientX;
          const dy = t0.clientY - t1.clientY;
          globalLastPanDist = Math.hypot(dx, dy);
          globalMoved = 0;

          g.drag = true;
          g.dragMode = "pan";
          g.movedDistance = 0;
          return;
        }

        const touch = e.touches ? e.touches[0] : e;
        const g = pickGlobe(touch.clientX, touch.clientY);
        if (!g) return;
        activeGlobe = g;

        pinchMode = false;
        globalDrag = true;
        globalDragMode = e.button === 2 ? "pan" : "rotate";
        globalLastX = touch.clientX;
        globalLastY = touch.clientY;
        globalMoved = 0;

        g.drag = true;
        g.dragMode = globalDragMode;
        g.movedDistance = 0;
      }

      function pointerMove(e) {
        if (!globalDrag) return;
        e.preventDefault();

        const g = activeGlobe;
        if (!g) return;

        if (e.touches && e.touches.length === 2 && pinchMode) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];

          const cxNow = (t0.clientX + t1.clientX) / 2;
          const cyNow = (t0.clientY + t1.clientY) / 2;

          const dxCenter = cxNow - globalLastX;
          const dyCenter = cyNow - globalLastY;
          globalLastX = cxNow;
          globalLastY = cyNow;
          globalMoved += Math.hypot(dxCenter, dyCenter);

          g.viewOffsetX += dxCenter;
          g.viewOffsetY += dyCenter;

          const dx = t0.clientX - t1.clientX;
          const dy = t0.clientY - t1.clientY;
          const dist = Math.hypot(dx, dy);
          const ratio = dist / globalLastPanDist;
          globalLastPanDist = dist;
          g.viewScale *= ratio;
          g.viewScale = Math.max(0.6, Math.min(2.5, g.viewScale));
          return;
        }

        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX;
        const y = touch.clientY;
        const dx = x - globalLastX;
        const dy = y - globalLastY;
        globalLastX = x;
        globalLastY = y;
        globalMoved += Math.hypot(dx, dy);

        if (globalDragMode === "rotate") {
          g.rotY += dx * 0.004;
          g.rotX += dy * 0.004;
          g.rotX = Math.max(
            -Math.PI / 2 + 0.2,
            Math.min(Math.PI / 2 - 0.2, g.rotX)
          );
        } else if (globalDragMode === "pan") {
          g.viewOffsetX += dx;
          g.viewOffsetY += dy;
        }
      }

      function pointerUp(e) {
        if (!globalDrag) return;

        const g = activeGlobe;
        if (!g) {
          globalDrag = false;
          return;
        }

        g.drag = false;
        globalDrag = false;

        // klik na slot (mal√Ω pohyb, jen p≈ôi rotaci)
        if (!pinchMode && globalDragMode === "rotate" && globalMoved < 12) {
          const touch = e.changedTouches ? e.changedTouches[0] : e;
          const local = screenToGlobeLocal(g, touch.clientX, touch.clientY);

          const radius = baseRadius * g.radiusScale;
          const slotW = (radius * 0.35) / 3;
          const slotH = slotW * 0.65;

          for (const slot of g.slots) {
            const dx = local.x - slot.localX;
            const dy = local.y - slot.localY;
            if (Math.abs(dx) <= slotW / 2 && Math.abs(dy) <= slotH / 2) {
              alert(
                "Koule " +
                  g.id +
                  " ‚Ä¢ otev≈ô√≠t svƒõt: " +
                  slot.label +
                  " (slot " +
                  slot.id +
                  ")"
              );
              break;
            }
          }
        }
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);
      window.addEventListener("contextmenu", (e) => e.preventDefault());

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      window.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp, { passive: false });
      window.addEventListener("touchcancel", pointerUp, { passive: false });

      // zoom koleƒçkem ‚Äì aktivn√≠ koule
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        if (!activeGlobe) return;
        const delta = e.deltaY;
        const factor = delta > 0 ? 0.9 : 1.1;
        activeGlobe.viewScale *= factor;
        activeGlobe.viewScale = Math.max(
          0.6,
          Math.min(2.5, activeGlobe.viewScale)
        );
      });
    </script>
  </body>
</html>
