<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Vivere atque FruiT ‚Ä¢ Platforma svƒõt≈Ø</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(900px, 100vw);
        height: min(600px, 100vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.04);
        overflow: hidden;
      }

      #platform-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="platform-canvas"></canvas>

        <div class="hud" id="hud-left">
          üåÄ t√°hni prstem / my≈°√≠ ‚Äì klikni na svƒõt
        </div>
        <div class="hud-right">v0.1 ‚Ä¢ platforma 4 svƒõt≈Ø</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("platform-canvas");
      const ctx = canvas.getContext("2d");
      const hudLeft = document.getElementById("hud-left");

      let width = 0;
      let height = 0;
      let cx = 0;
      let cy = 0;
      const dpr = window.devicePixelRatio || 1;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        cx = width / 2;
        cy = height / 2;
      }

      resize();
      window.addEventListener("resize", resize);

      // --- definice svƒõt≈Ø (4 hlavn√≠ svƒõty kolem st≈ôedu) ---

      const worlds = [
        {
          id: "heroes",
          label: "Hrdinov√©",
          orbitRadius: 150,
          baseAngle: -Math.PI / 2,
          angle: -Math.PI / 2,
          speed: 0.18,
          color: "#ffdca0",
          folderHint: "Braska-Hlava / hrdinov√©"
        },
        {
          id: "rules",
          label: "Hra + pravidla",
          orbitRadius: 170,
          baseAngle: 0,
          angle: 0,
          speed: 0.12,
          color: "#ffe6b8",
          folderHint: "App-Style-System / logika hry"
        },
        {
          id: "language",
          label: "Jazyk",
          orbitRadius: 150,
          baseAngle: Math.PI / 2,
          angle: Math.PI / 2,
          speed: 0.16,
          color: "#ffe0c2",
          folderHint: "k√≥dy, glyphy, p√≠smenka"
        },
        {
          id: "perspective",
          label: "Zemƒõ / √∫hel pohledu",
          orbitRadius: 170,
          baseAngle: Math.PI,
          angle: Math.PI,
          speed: 0.14,
          color: "#ffcf93",
          folderHint: "mapy, 21261927, pohledy"
        }
      ];

      const worldRadius = 26;
      const worldHitRadius = 32;
      let worldScreenPositions = [];

      // --- animace / ƒças ---
      let lastTime = 0;

      function drawPlatform(dt) {
        ctx.clearRect(0, 0, width, height);

        // podkladov√Ω glow
        const gBg = ctx.createRadialGradient(
          cx,
          cy - 40,
          40,
          cx,
          cy + 40,
          Math.max(width, height) * 0.7
        );
        gBg.addColorStop(0, "rgba(255, 210, 140, 0.08)");
        gBg.addColorStop(1, "rgba(0, 0, 0, 1)");
        ctx.fillStyle = gBg;
        ctx.fillRect(0, 0, width, height);

        // centr√°ln√≠ torus (VaF'i'T j√°dro)
        const outerR = 95;
        const innerR = 60;

        // vnƒõj≈°√≠ kruh
        ctx.beginPath();
        ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
        const outerGrad = ctx.createRadialGradient(
          cx - 20,
          cy - 30,
          10,
          cx,
          cy + 40,
          outerR * 1.2
        );
        outerGrad.addColorStop(0, "#382213");
        outerGrad.addColorStop(0.6, "#1b0f10");
        outerGrad.addColorStop(1, "#050308");
        ctx.fillStyle = outerGrad;
        ctx.fill();

        ctx.strokeStyle = "rgba(255, 206, 140, 0.9)";
        ctx.lineWidth = 2;
        ctx.shadowColor = "rgba(255, 206, 140, 0.9)";
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // vnit≈ôn√≠ "d√≠ra" toru
        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // linky na toru
        ctx.save();
        ctx.strokeStyle = "rgba(255, 215, 160, 0.35)";
        ctx.lineWidth = 0.8;
        const lanes = 10;
        for (let i = 0; i < lanes; i++) {
          const a = (i / lanes) * Math.PI * 2 + performance.now() * 0.0002;
          const x1 = cx + innerR * Math.cos(a);
          const y1 = cy + innerR * Math.sin(a);
          const x2 = cx + outerR * Math.cos(a);
          const y2 = cy + outerR * Math.sin(a);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        ctx.restore();

        // text ve st≈ôedu ‚Äì na≈°e dvojice + n√°zev
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(-Math.PI / 16);

        ctx.font = "700 16px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(255, 210, 150, 0.9)";
        ctx.shadowBlur = 16;
        ctx.fillStyle = "rgba(255, 225, 180, 0.96)";

        const centerText =
          "{*(¬∞.).)// Vivere atque Fru'ii'T \\\\(.(.¬∞)*]";
        ctx.fillText(centerText, 0, 0);

        ctx.shadowBlur = 0;
        ctx.restore();

        // orbit√°ln√≠ kruhy pro svƒõty
        ctx.save();
        ctx.strokeStyle = "rgba(255, 210, 150, 0.4)";
        ctx.lineWidth = 0.8;
        worlds.forEach((w) => {
          ctx.beginPath();
          ctx.setLineDash([4, 4]);
          ctx.arc(cx, cy, w.orbitRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        });
        ctx.restore();

        // svƒõty
        worldScreenPositions = [];
        worlds.forEach((w) => {
          w.angle += w.speed * dt * 0.25;

          const wx = cx + w.orbitRadius * Math.cos(w.angle);
          const wy = cy + w.orbitRadius * Math.sin(w.angle);

          worldScreenPositions.push({
            id: w.id,
            x: wx,
            y: wy,
            r: worldRadius
          });

          // glow
          const wg = ctx.createRadialGradient(
            wx - 6,
            wy - 6,
            4,
            wx,
            wy + 10,
            worldRadius * 1.6
          );
          wg.addColorStop(0, "rgba(255, 240, 200, 0.95)");
          wg.addColorStop(0.5, w.color);
          wg.addColorStop(1, "rgba(10, 5, 0, 0.9)");

          ctx.beginPath();
          ctx.arc(wx, wy, worldRadius, 0, Math.PI * 2);
          ctx.fillStyle = wg;
          ctx.fill();

          ctx.strokeStyle = "rgba(255, 225, 180, 0.95)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(wx, wy, worldRadius, 0, Math.PI * 2);
          ctx.stroke();

          // p√°r "slot" linek na povrchu svƒõta
          ctx.save();
          ctx.strokeStyle = "rgba(120, 70, 30, 0.65)";
          ctx.lineWidth = 0.6;
          ctx.translate(wx, wy);
          ctx.rotate(w.angle * 0.9);

          for (let i = -1; i <= 1; i++) {
            const yy = (i * worldRadius) / 3;
            ctx.beginPath();
            ctx.arc(0, yy, worldRadius * 0.85, -0.9, 0.9);
            ctx.stroke();
          }
          ctx.restore();

          // popisek svƒõta
          ctx.font = "600 11px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.fillStyle = "rgba(255, 230, 190, 0.92)";
          ctx.fillText(w.label, wx, wy + worldRadius + 6);
        });
      }

      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        drawPlatform(dt);
        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);

      // --- ovl√°d√°n√≠: ta≈æen√≠ = jemn√© ot√°ƒçen√≠ cel√© sc√©ny ---
      let drag = false;
      let lastX = 0;
      let baseRotation = 0;
      let currentRotation = 0;

      function applySceneRotation() {
        // otoƒç√≠me jen sou≈ôadnicov√Ω syst√©m pro svƒõty
        worlds.forEach((w, idx) => {
          const base = w.baseAngle + currentRotation;
          w.angle = base;
        });
      }

      function pointerDown(e) {
        drag = true;
        const touch = e.touches ? e.touches[0] : e;
        lastX = touch.clientX;
      }

      function pointerMove(e) {
        if (!drag) return;
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX;
        const dx = x - lastX;
        lastX = x;

        currentRotation += dx * 0.003;
        applySceneRotation();
      }

      function pointerUp() {
        drag = false;
      }

      // kliknut√≠ na svƒõt
      function pointerClick(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        let hit = null;
        for (const pos of worldScreenPositions) {
          const dx = x - pos.x;
          const dy = y - pos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= worldHitRadius) {
            hit = pos.id;
            break;
          }
        }

        if (hit) {
          const w = worlds.find((ww) => ww.id === hit);
          if (w) {
            hudLeft.textContent =
              "üåç vybran√Ω svƒõt: " +
              w.label +
              " ‚Ä¢ (pak napoj√≠me slo≈æku: " +
              w.folderHint +
              ")";
            // SEM POZDƒöJI: p≈ôesmƒõrov√°n√≠ na konkr√©tn√≠ HTML:
            // window.location.href = "./cesta-k-souboru/index.html";
          }
        }
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: true });
      window.addEventListener("touchmove", pointerMove, { passive: true });
      window.addEventListener("touchend", pointerUp);

      canvas.addEventListener("click", pointerClick);
      canvas.addEventListener("touchend", pointerClick);
    </script>
  </body>
</html>
