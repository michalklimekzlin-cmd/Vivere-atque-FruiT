<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Prstenec se sloty</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      #ring-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.8;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="ring-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst = ot√°ƒçen√≠ prstence ‚Ä¢ 2 prsty / koleƒçko = zoom ‚Ä¢ sloty =
          budouc√≠ m√≠sta pro svƒõty
        </div>
        <div class="hud-right">v0.4 ‚Ä¢ Zm√°ƒçknut√Ω prstenec se svƒõty</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("ring-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      const dpr = window.devicePixelRatio || 1;

      let baseRadius = 0;

      // zoom
      let viewScale = 1;
      let targetViewScale = 1;

      // rotace prstence
      let rotX = -0.7;
      let rotY = 0.4;
      let targetRotX = rotX;
      let targetRotY = rotY;

      // interakce
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      // pinch
      let pinchStartDist = 0;
      let pinchStartScale = 1;
      let isPinching = false;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        baseRadius = Math.min(width, height) * 0.22;
      }

      resize();
      window.addEventListener("resize", resize);

      // 3D ‚Üí 2D projekce
      function projectPoint(x, y, z) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        return {
          x: width / 2 + x2 * viewScale,
          y: height / 2 + y1 * viewScale,
          z: z2,
        };
      }

      function drawRing() {
        ctx.clearRect(0, 0, width, height);

        // pozad√≠ aura
        const gBg = ctx.createRadialGradient(
          width / 2,
          height / 2 - baseRadius * 0.5,
          baseRadius * 0.1,
          width / 2,
          height / 2,
          baseRadius * 3
        );
        gBg.addColorStop(0, "rgba(255, 190, 130, 0.16)");
        gBg.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gBg;
        ctx.fillRect(0, 0, width, height);

        const GOLD = "rgba(255, 210, 150, 0.95)";
        const GOLD_SOFT = "rgba(255, 190, 130, 0.35)";

        // --- TVAR PRSTENCE (ZM√ÅƒåKNUT√ù DONUT) ---
        // z√°kladn√≠ hodnoty
        const R = baseRadius * 1.45; // hlavn√≠ polomƒõr (vƒõt≈°√≠ ‚Äì 3 a 4 se rozt√°hnou)
        const r = baseRadius * 0.4; // tlou≈°≈•ka tƒõla

        // "zm√°ƒçknut√≠ o zem"
        const stretchXZ = 1.15; // rozt√°hnout do stran (3,4)
        const squashY = 0.45; // zm√°ƒçknout naho≈ôe/dole (1,2)

        const segmentsU = 48; // kolem dokola
        const segmentsV = 18; // p≈ôes tlou≈°≈•ku

        ctx.lineWidth = 1;
        ctx.strokeStyle = GOLD;

        // pomocn√° funkce ‚Äì jeden bod toru po deformaci
        function torusPoint(u, v) {
          const cosV = Math.cos(v);
          const sinV = Math.sin(v);

          let x = (R + r * cosV) * Math.cos(u);
          let y = r * sinV;
          let z = (R + r * cosV) * Math.sin(u);

          // deformace
          x *= stretchXZ;
          z *= stretchXZ;
          y *= squashY;

          return projectPoint(x, y, z);
        }

        // mƒõkk√° aura kolem prstence
        ctx.save();
        ctx.globalAlpha = 0.2;
        for (let v = 0; v <= segmentsV; v++) {
          const vv = (v / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let u = 0; u <= segmentsU; u++) {
            const uu = (u / segmentsU) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }
        ctx.restore();

        // m≈ô√≠≈æka ‚Äì pod√©ln√© linie (fixn√≠ u)
        for (let uIdx = 0; uIdx < segmentsU; uIdx++) {
          const uu = (uIdx / segmentsU) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let vIdx = 0; vIdx <= segmentsV; vIdx++) {
            const vv = (vIdx / segmentsV) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }

        // m≈ô√≠≈æka ‚Äì kruhov√© linie (fixn√≠ v)
        for (let vIdx = 0; vIdx <= segmentsV; vIdx++) {
          const vv = (vIdx / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let uIdx = 0; uIdx <= segmentsU; uIdx++) {
            const uu = (uIdx / segmentsU) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }

        // lehk√Ω okraj ‚Äì aura
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.lineWidth = 2;
        ctx.strokeStyle = GOLD_SOFT;
        for (let vIdx = 0; vIdx <= segmentsV; vIdx += 3) {
          const vv = (vIdx / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let uIdx = 0; uIdx <= segmentsU; uIdx++) {
            const uu = (uIdx / segmentsU) * Math.PI * 2;
            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }
        ctx.restore();

        // budouc√≠ SLOTY ‚Äì 4 naznaƒçen√©
        const slotPositions = [0, Math.PI / 2.7, -Math.PI / 2.7, Math.PI];
        ctx.lineWidth = 1;
        ctx.strokeStyle = GOLD;
        ctx.fillStyle = "rgba(6,6,10,0.95)";
        ctx.shadowColor = "rgba(255, 200, 140, 0.9)";
        ctx.shadowBlur = 6;

        const slotSize = baseRadius * 0.22;

        for (const ang of slotPositions) {
          const uu = ang;
          const vv = 0; // vnƒõj≈°√≠ strana prstence

          const p = torusPoint(uu, vv);
          if (p.z < 0) continue;

          const w = slotSize;
          const h = slotSize * 0.6;
          const rSlot = 8;

          ctx.save();
          ctx.translate(p.x, p.y);

          ctx.beginPath();
          ctx.moveTo(-w / 2 + rSlot, -h / 2);
          ctx.lineTo(w / 2 - rSlot, -h / 2);
          ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + rSlot);
          ctx.lineTo(w / 2, h / 2 - rSlot);
          ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - rSlot, h / 2);
          ctx.lineTo(-w / 2 + rSlot, h / 2);
          ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - rSlot);
          ctx.lineTo(-w / 2, -h / 2 + rSlot);
          ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + rSlot, -h / 2);
          ctx.closePath();

          ctx.fill();
          ctx.stroke();

          ctx.font = "9px system-ui";
          ctx.fillStyle = "rgba(255,220,170,0.96)";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("slot", 0, 1);

          ctx.restore();
        }

        ctx.shadowBlur = 0;
      }

      function loop() {
        // jemn√Ω auto-rot, kdy≈æ se nedot√Ωk√°≈°
        if (!dragging && !isPinching) {
          targetRotY += 0.0025;
        }

        const k = 0.12;
        rotX += (targetRotX - rotX) * k;
        rotY += (targetRotY - rotY) * k;
        viewScale += (targetViewScale - viewScale) * k;

        drawRing();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // --- interakce ---

      function onPointerDown(clientX, clientY) {
        dragging = true;
        lastX = clientX;
        lastY = clientY;
      }

      function onPointerMove(clientX, clientY) {
        if (!dragging || isPinching) return;
        const dx = clientX - lastX;
        const dy = clientY - lastY;
        lastX = clientX;
        lastY = clientY;

        targetRotY += dx * 0.01;
        targetRotX += dy * 0.01;
      }

      function onPointerUp() {
        dragging = false;
      }

      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        onPointerDown(e.clientX, e.clientY);
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        e.preventDefault();
        onPointerMove(e.clientX, e.clientY);
      });
      window.addEventListener("mouseup", () => {
        onPointerUp();
      });

      // touch
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            isPinching = false;
            const t = e.touches[0];
            onPointerDown(t.clientX, t.clientY);
          } else if (e.touches.length === 2) {
            dragging = false;
            isPinching = true;
            const t0 = e.touches[0];
            const t1 = e.touches[1];
            pinchStartDist = Math.hypot(
              t0.clientX - t1.clientX,
              t0.clientY - t1.clientY
            );
            pinchStartScale = targetViewScale;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length === 1 && dragging && !isPinching) {
            e.preventDefault();
            const t = e.touches[0];
            onPointerMove(t.clientX, t.clientY);
          } else if (e.touches.length === 2 && isPinching) {
            e.preventDefault();
            const t0 = e.touches[0];
            const t1 = e.touches[1];
            const dist = Math.hypot(
              t0.clientX - t1.clientX,
              t0.clientY - t1.clientY
            );
            const ratio = dist / pinchStartDist;
            let newScale = pinchStartScale * ratio;
            newScale = Math.max(0.7, Math.min(2.8, newScale));
            targetViewScale = newScale;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchend",
        () => {
          dragging = false;
          isPinching = false;
        },
        { passive: false }
      );
      window.addEventListener(
        "touchcancel",
        () => {
          dragging = false;
          isPinching = false;
        },
        { passive: false }
      );

      // koleƒçko my≈°i = zoom
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        let newScale = targetViewScale * factor;
        newScale = Math.max(0.7, Math.min(2.8, newScale));
        targetViewScale = newScale;
      });
    </script>
  </body>
</html>
