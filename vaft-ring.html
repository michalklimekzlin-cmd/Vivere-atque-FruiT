<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Prstenec + Signal Sphere</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      #ring-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.8;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="ring-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst = ot√°ƒçen√≠ prstence ‚Ä¢ 2 prsty / koleƒçko = zoom ‚Ä¢ st≈ôed = VaF'i'T
          Signal Sphere
        </div>
        <div class="hud-right">v0.6 ‚Ä¢ Prstenec + Signal Sphere</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("ring-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      const dpr = window.devicePixelRatio || 1;

      let baseRadius = 0;

      // zoom
      let viewScale = 1;
      let targetViewScale = 1;

      // rotace prstence + koule (kamera)
      let rotX = -0.7;
      let rotY = 0.4;
      let targetRotX = rotX;
      let targetRotY = rotY;

      // interakce
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      // pinch
      let pinchStartDist = 0;
      let pinchStartScale = 1;
      let isPinching = false;

      // --- Signal Sphere (ƒç√≠sla) ---
      const spherePoints = [];
      const sphereChars = "0123456789";
      let sphereSpin = 0;

      function initSpherePoints() {
        spherePoints.length = 0;
        const bands = 16; // poƒçet "≈ô√°dk≈Ø"
        const segs = 32; // poƒçet bod≈Ø v ≈ô√°dku

        let idx = 0;
        for (let b = 0; b <= bands; b++) {
          const v = (b / bands) * Math.PI - Math.PI / 2; // -pi/2..pi/2 (≈°√≠≈ôka)
          for (let s = 0; s < segs; s++) {
            const u = (s / segs) * Math.PI * 2; // 0..2pi kolem dokola
            const ch = sphereChars[idx % sphereChars.length];
            idx++;
            spherePoints.push({
              lat: v,
              lon: u,
              char: ch,
              phase: Math.random() * Math.PI * 2,
            });
          }
        }
      }

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        baseRadius = Math.min(width, height) * 0.22;

        initSpherePoints();
      }

      resize();
      window.addEventListener("resize", resize);

      // 3D ‚Üí 2D projekce (sd√≠len√° pro prstenec i kouli)
      function projectPoint(x, y, z) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);

        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        return {
          x: width / 2 + x2 * viewScale,
          y: height / 2 + y1 * viewScale,
          z: z2,
        };
      }

      // ---------- PRSTENEC ----------

      function drawRing() {
        const GOLD = "rgba(255, 210, 150, 0.95)";
        const GOLD_SOFT = "rgba(255, 190, 130, 0.35)";

        // z√°klad prstence
        const R = baseRadius * 1.45; // hlavn√≠ polomƒõr
        const rBase = baseRadius * 0.4; // z√°kladn√≠ tlou≈°≈•ka

        // "zm√°ƒçknut√≠ o zem"
        const stretchXZ = 1.15; // do stran
        const squashY = 0.45; // naho≈ôe/dole

        const segmentsU = 48;
        const segmentsV = 18;

        ctx.lineWidth = 1;
        ctx.strokeStyle = GOLD;

        function torusPoint(u, v) {
          const cosV = Math.cos(v);
          const sinV = Math.sin(v);
          const sinU = Math.sin(u);

          // p≈ôedn√≠ p≈Ølka tlust≈°√≠, zadn√≠ tenƒç√≠
          const frontFactor = 1.4;
          const backFactor = 0.55;
          const rLocal = rBase * (sinU > 0 ? frontFactor : backFactor);

          let x = (R + rLocal * cosV) * Math.cos(u);
          let y = rLocal * sinV;
          let z = (R + rLocal * cosV) * Math.sin(u);

          x *= stretchXZ;
          z *= stretchXZ;
          y *= squashY;

          return projectPoint(x, y, z);
        }

        // mƒõkk√° aura kolem prstence
        ctx.save();
        ctx.globalAlpha = 0.2;
        for (let v = 0; v <= segmentsV; v++) {
          const vv = (v / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let u = 0; u <= segmentsU; u++) {
            const uu = (u / segmentsU) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }
        ctx.restore();

        // m≈ô√≠≈æka ‚Äì pod√©ln√© linie
        for (let uIdx = 0; uIdx < segmentsU; uIdx++) {
          const uu = (uIdx / segmentsU) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let vIdx = 0; vIdx <= segmentsV; vIdx++) {
            const vv = (vIdx / segmentsV) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }

        // m≈ô√≠≈æka ‚Äì kruhov√© linie
        for (let vIdx = 0; vIdx <= segmentsV; vIdx++) {
          const vv = (vIdx / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let uIdx = 0; uIdx <= segmentsU; uIdx++) {
            const uu = (uIdx / segmentsU) * Math.PI * 2;

            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }

        // lehk√° aura
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.lineWidth = 2;
        ctx.strokeStyle = GOLD_SOFT;
        for (let vIdx = 0; vIdx <= segmentsV; vIdx += 3) {
          const vv = (vIdx / segmentsV) * Math.PI * 2;
          ctx.beginPath();
          let started = false;
          for (let uIdx = 0; uIdx <= segmentsU; uIdx++) {
            const uu = (uIdx / segmentsU) * Math.PI * 2;
            const p = torusPoint(uu, vv);
            if (p.z < 0) continue;
            if (!started) {
              ctx.moveTo(p.x, p.y);
              started = true;
            } else {
              ctx.lineTo(p.x, p.y);
            }
          }
          if (started) ctx.stroke();
        }
        ctx.restore();

        // sloty ‚Äì 4 naznaƒçen√©
        const GOLD = "rgba(255, 210, 150, 0.95)";
        const slotPositions = [0, Math.PI / 2.7, -Math.PI / 2.7, Math.PI];

        ctx.lineWidth = 1;
        ctx.strokeStyle = GOLD;
        ctx.fillStyle = "rgba(6,6,10,0.95)";
        ctx.shadowColor = "rgba(255, 200, 140, 0.9)";
        ctx.shadowBlur = 6;

        const slotSize = baseRadius * 0.22;

        for (const ang of slotPositions) {
          const uu = ang;
          const vv = 0;

          const p = torusPoint(uu, vv);
          if (p.z < 0) continue;

          const w = slotSize;
          const h = slotSize * 0.6;
          const rSlot = 8;

          ctx.save();
          ctx.translate(p.x, p.y);

          ctx.beginPath();
          ctx.moveTo(-w / 2 + rSlot, -h / 2);
          ctx.lineTo(w / 2 - rSlot, -h / 2);
          ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + rSlot);
          ctx.lineTo(w / 2, h / 2 - rSlot);
          ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - rSlot, h / 2);
          ctx.lineTo(-w / 2 + rSlot, h / 2);
          ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - rSlot);
          ctx.lineTo(-w / 2, -h / 2 + rSlot);
          ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + rSlot, -h / 2);
          ctx.closePath();

          ctx.fill();
          ctx.stroke();

          ctx.font = "9px system-ui";
          ctx.fillStyle = "rgba(255,220,170,0.96)";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("slot", 0, 1);

          ctx.restore();
        }

        ctx.shadowBlur = 0;
      }

      // ---------- SIGNAL SPHERE UPROST≈òED ----------

      function drawSignalSphere() {
        const rSphere = baseRadius * 0.75; // velikost koule
        const GOLD = "rgba(255, 210, 150, 0.95)";

        // st√≠n pod koul√≠
        const centerProj = projectPoint(0, 0, 0);
        const rPix = rSphere * viewScale;

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(
          centerProj.x,
          centerProj.y + rPix * 0.95,
          rPix * 1.3,
          rPix * 0.4,
          0,
          0,
          Math.PI * 2
        );
        const gShadow = ctx.createRadialGradient(
          centerProj.x,
          centerProj.y + rPix * 0.95,
          rPix * 0.5,
          centerProj.x,
          centerProj.y + rPix * 0.95,
          rPix * 1.4
        );
        gShadow.addColorStop(0, "rgba(10,6,4,0.9)");
        gShadow.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gShadow;
        ctx.fill();
        ctx.restore();

        // tƒõlo koule (glow + hrana)
        ctx.save();
        ctx.beginPath();
        ctx.arc(centerProj.x, centerProj.y, rPix * 1.03, 0, Math.PI * 2);
        const gAura = ctx.createRadialGradient(
          centerProj.x,
          centerProj.y - rPix * 0.5,
          rPix * 0.3,
          centerProj.x,
          centerProj.y + rPix * 0.3,
          rPix * 1.4
        );
        gAura.addColorStop(0, "rgba(255, 205, 150, 0.18)");
        gAura.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gAura;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(centerProj.x, centerProj.y, rPix, 0, Math.PI * 2);
        const gBall = ctx.createRadialGradient(
          centerProj.x - rPix * 0.3,
          centerProj.y - rPix * 0.4,
          rPix * 0.2,
          centerProj.x,
          centerProj.y + rPix * 0.4,
          rPix * 1.1
        );
        gBall.addColorStop(0, "#2d1d0f");
        gBall.addColorStop(0.6, "#1b1012");
        gBall.addColorStop(1, "#050308");
        ctx.fillStyle = gBall;
        ctx.fill();

        ctx.strokeStyle = "rgba(255, 210, 150, 0.98)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 210, 150, 0.9)";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(centerProj.x, centerProj.y, rPix, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        ctx.shadowBlur = 0;

        // ƒç√≠sla na povrchu koule
        ctx.save();
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = GOLD;
        ctx.shadowColor = "rgba(255, 210, 150, 0.8)";
        ctx.shadowBlur = 6;

        const spin = sphereSpin;

        for (const p0 of spherePoints) {
          const lat = p0.lat;
          const lon = p0.lon + spin; // rotace
          const cl = Math.cos(lat);
          const sl = Math.sin(lat);

          const x = rSphere * cl * Math.cos(lon);
          const y = rSphere * sl;
          const z = rSphere * cl * Math.sin(lon);

          const p = projectPoint(x, y, z);
          if (p.z < 0) continue; // zadn√≠ strana

          // men≈°√≠ flicker
          const flicker =
            0.65 + 0.35 * Math.sin(sphereSpin * 2.0 + p0.phase);
          ctx.globalAlpha = flicker;

          ctx.fillText(p0.char, p.x, p.y);
        }

        ctx.restore();
        ctx.globalAlpha = 1;
      }

      // ---------- SC√âNA ----------

      function drawScene() {
        ctx.clearRect(0, 0, width, height);

        // pozad√≠ (celkov√° aura)
        const gBg = ctx.createRadialGradient(
          width / 2,
          height / 2 - baseRadius,
          baseRadius * 0.2,
          width / 2,
          height / 2,
          baseRadius * 4
        );
        gBg.addColorStop(0, "rgba(255, 195, 140, 0.16)");
        gBg.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = gBg;
        ctx.fillRect(0, 0, width, height);

        // nejd≈ô√≠v prstenec
        drawRing();

        // pak signal sphere uprost≈ôed
        drawSignalSphere();
      }

      function loop() {
        if (!dragging && !isPinching) {
          targetRotY += 0.0025;
        }

        sphereSpin += 0.012; // ot√°ƒçen√≠ sign√°ln√≠ koule

        const k = 0.12;
        rotX += (targetRotX - rotX) * k;
        rotY += (targetRotY - rotY) * k;
        viewScale += (targetViewScale - viewScale) * k;

        drawScene();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---------- interakce ----------

      function onPointerDown(clientX, clientY) {
        dragging = true;
        lastX = clientX;
        lastY = clientY;
      }

      function onPointerMove(clientX, clientY) {
        if (!dragging || isPinching) return;
        const dx = clientX - lastX;
        const dy = clientY - lastY;
        lastX = clientX;
        lastY = clientY;

        targetRotY += dx * 0.01;
        targetRotX += dy * 0.01;
      }

      function onPointerUp() {
        dragging = false;
      }

      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        onPointerDown(e.clientX, e.clientY);
      });
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        e.preventDefault();
        onPointerMove(e.clientX, e.clientY);
      });
      window.addEventListener("mouseup", () => {
        onPointerUp();
      });

      // touch
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (e.touches.length === 1) {
            isPinching = false;
            const t = e.touches[0];
            onPointerDown(t.clientX, t.clientY);
          } else if (e.touches.length === 2) {
            dragging = false;
            isPinching = true;
            const t0 = e.touches[0];
            const t1 = e.touches[1];
            pinchStartDist = Math.hypot(
              t0.clientX - t1.clientX,
              t0.clientY - t1.clientY
            );
            pinchStartScale = targetViewScale;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (e.touches.length === 1 && dragging && !isPinching) {
            e.preventDefault();
            const t = e.touches[0];
            onPointerMove(t.clientX, t.clientY);
          } else if (e.touches.length === 2 && isPinching) {
            e.preventDefault();
            const t0 = e.touches[0];
            const t1 = e.touches[1];
            const dist = Math.hypot(
              t0.clientX - t1.clientX,
              t0.clientY - t1.clientY
            );
            const ratio = dist / pinchStartDist;
            let newScale = pinchStartScale * ratio;
            newScale = Math.max(0.7, Math.min(2.8, newScale));
            targetViewScale = newScale;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchend",
        () => {
          dragging = false;
          isPinching = false;
        },
        { passive: false }
      );
      window.addEventListener(
        "touchcancel",
        () => {
          dragging = false;
          isPinching = false;
        },
        { passive: false }
      );

      // koleƒçko my≈°i = zoom
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        let newScale = targetViewScale * factor;
        newScale = Math.max(0.7, Math.min(2.8, newScale));
        targetViewScale = newScale;
      });
    </script>
  </body>
</html>
