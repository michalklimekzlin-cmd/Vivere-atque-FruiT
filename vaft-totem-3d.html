<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T â€¢ 3D Totem z pÃ­smenek</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.9);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #totem-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      /* skrytÃ½ zdroj totemu â€“ tady je tvÅ¯j text */
      #totem-source {
        display: none;
        white-space: pre;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="totem-canvas"></canvas>

        <div class="hud">
          ğŸŒ€ 1 prst / myÅ¡ = nÃ¡klon â€¢ pinch / koleÄko = zoom
        </div>
        <div class="hud-right">
          v1.2 â€¢ VaF'i'T ASCII Totem â€¢ styl pÃ­smenkovÃ© planety
        </div>

        <!-- TADY JE TVÅ®J TOTEM â€“ mÅ¯Å¾eÅ¡ ho v klidu upravovat -->
        <pre id="totem-source">
                                       .                                     
                                      :  :
                                   ([{ğŸ«¡Â°]})
                                     7i_,;â€˜
                                   `Ë‡`'|'Â´Ë‡Â´                                  
                                 ~ KÃ†.:Å¸:.ÅšM ~
                              Vivere atque FruiT   
                 `Â¡(â€¢Â°(â€¢Â°.)Â´}:|:[*(Â°.â€¢.)|(.â€¢.Â°)*]:|:(â€(Â°.â€¢)Â°â€¢)Â¡Â´
           Ä¯::::Ä«::::Â¡::[&,;â€™{(Â°â€¢.)(.Â°â€¢)}:{â€¢[]â€¢}â€¢],;â€˜#]::Ã¯::::Ä¯j::::j
                `â€˜.,_i,/`[Â´'|'`_.:Å¸:._,7i.â€¢Â´Ë‡â€™,:.,_,;â€™`Ë‡â€™.,_i,/`
                            (â€œ~â€œâ€œÂ´Â°;)../Â´/Â´/Â´_)_]_} 
                            `\%.â€¢â€˜Ë‡Â´1Â¡;:.|IÂ°â€â€™â€™Â´/â€˜Â´
                                `Â°â€˜:;iâ€™/â˜»\i;:â€˜Â°Â´
                                    ~/`\|/Â´\~
                                    `Ë‡'ÃŒÄ«Ã'Ë‡Â´
                                      q[Â¥]p
                                    .,:Â´|`:,
                                    (.|0â€¢0|.)
                                      ()!!()/â€˜
        </pre>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("totem-canvas");
      const ctx = canvas.getContext("2d");

      const dpr = window.devicePixelRatio || 1;
      let width = 0;
      let height = 0;

      let viewScale = 1;
      let targetViewScale = 1;

      // nÃ¡klon scÃ©ny (X = nahoru/dolÅ¯, Y = do stran)
      let tiltX = -0.35;
      let tiltY = 0.15;
      let targetTiltX = tiltX;
      let targetTiltY = tiltY;

      // totem se automaticky NEOTÃÄŒÃ â€“ stojÃ­ na mÃ­stÄ› (jako stÃ©la)
      let rotationY = 0;
      const autoRotate = 0; // kdyÅ¾ chceÅ¡ lehkÃ© toÄenÃ­, dej tÅ™eba 0.1

      // naÄtenÃ­ textu totemu
      const rawText = document.getElementById("totem-source").innerText;
      const lines = rawText
        .split("\n")
        .filter((l) => l.trim() !== "" || l.length > 0);

      const maxLen = lines.reduce((m, l) => Math.max(m, l.length), 0);

      // Vivere prstenec jako u planety
      const vivereText = "{*(Â°.).)// Vivere atque FruiT \\\\(.(.Â°)*}";

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      resize();
      window.addEventListener("resize", resize);

      function projectPoint(x, y, z) {
        // rotace kolem Y (kdybychom nÄ›kdy chtÄ›li lehkÃ½ auto-rotate)
        const sinR = Math.sin(rotationY);
        const cosR = Math.cos(rotationY);
        let xR = x * cosR + z * sinR;
        let zR = -x * sinR + z * cosR;

        // nÃ¡klon kolem X a Y
        const sinX = Math.sin(tiltX);
        const cosX = Math.cos(tiltX);
        const sinY = Math.sin(tiltY);
        const cosY = Math.cos(tiltY);

        let y1 = y * cosX - zR * sinX;
        let z1 = y * sinX + zR * cosX;

        let x2 = xR * cosY + z1 * sinY;
        let z2 = -xR * sinY + z1 * cosY;

        const sx = width / 2 + x2 * viewScale;
        const sy = height / 2 + y1 * viewScale;

        return { sx, sy, z: z2 };
      }

      function drawBackground() {
        const g = ctx.createRadialGradient(
          width * 0.5,
          height * 0.15,
          0,
          width * 0.5,
          height * 0.6,
          height * 0.9
        );
        g.addColorStop(0, "#0b0815");
        g.addColorStop(1, "#020108");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);
      }

      function drawBaseGlow() {
        ctx.save();
        const baseY = height * 0.8;
        const baseR = Math.min(width, height) * 0.2 * viewScale;

        ctx.beginPath();
        ctx.ellipse(
          width / 2,
          baseY,
          baseR * 1.5,
          baseR * 0.6,
          0,
          0,
          Math.PI * 2
        );
        const g = ctx.createRadialGradient(
          width / 2,
          baseY,
          baseR * 0.3,
          width / 2,
          baseY,
          baseR * 1.7
        );
        g.addColorStop(0, "rgba(255, 210, 160, 0.35)");
        g.addColorStop(1, "rgba(0, 0, 0, 0.0)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function drawTotem(time) {
        const charW = 9;
        const lineH = 16;

        const towerHeight = lines.length * lineH;
        const towerWidth = maxLen * charW;

        // mÃ­rnÃ© zakÅ™ivenÃ­ â€“ ÄelnÃ­ stÄ›na do tvaru U (jako 3D stÃ©la)
        const curveRadius = towerWidth * 0.9;
        const curveAngle = Math.PI / 6; // cca 30Â°

        const depthOffset = curveRadius;

        ctx.save();
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255,220,180,0.95)";
        ctx.shadowColor = "rgba(255,200,150,0.9)";
        ctx.shadowBlur = 10;

        const centerY = height * 0.2; // posunutÃ­ totemu nahoru

        const points = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].padEnd(maxLen, " ");
          for (let j = 0; j < line.length; j++) {
            const ch = line[j];

            const localX = (j - maxLen / 2) * charW;
            const localY = (i - lines.length / 2) * lineH;

            // pÅ™emapovÃ¡nÃ­ X na Ãºhel v rozsahu [-curveAngle, curveAngle]
            const t = localX / (towerWidth / 2 || 1);
            const angle = t * curveAngle;

            const x3d = Math.sin(angle) * curveRadius;
            const z3d = Math.cos(angle) * curveRadius - depthOffset;
            const y3d = localY - towerHeight * 0.06;

            const proj = projectPoint(x3d, y3d, z3d);

            points.push({
              ch,
              i,
              j,
              sx: proj.sx,
              sy: proj.sy + centerY,
              z: proj.z,
            });
          }
        }

        // seÅ™adit podle hloubky (vzadu dÅ™Ã­v)
        points.sort((a, b) => a.z - b.z);

        for (const p of points) {
          const depthFactor =
            0.45 +
            0.55 *
              (1 -
                Math.min(
                  1,
                  (p.z + curveRadius) / (curveRadius * 2 + 1e-5)
                ));

          // jemnÃ© "dÃ½chÃ¡nÃ­" jako u pÃ­smenkovÃ© planety
          const phase = (p.i * 13 + p.j * 7) * 0.21;
          const flicker =
            0.6 + 0.4 * Math.sin(time * 1.4 + phase + p.z * 0.5);

          ctx.globalAlpha = depthFactor * flicker;
          ctx.fillText(p.ch, p.sx, p.sy);
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // Vivere prstenec kolem totemu (v 2D prostoru)
      function drawVivereRing(time) {
        const text = vivereText;
        const step = (Math.PI * 2) / text.length;

        const cx = width / 2;
        const cy = height * 0.42; // kolem "hrudi" totemu

        const radiusX = Math.min(width, height) * 0.22 * viewScale;
        const radiusY = radiusX * 0.4;

        ctx.save();
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 230, 185, 0.95)";
        ctx.shadowColor = "rgba(255, 210, 160, 0.9)";
        ctx.shadowBlur = 8;

        const baseAngle = time * 0.4;

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const angle = baseAngle + i * step;

          const x = cx + Math.cos(angle) * radiusX;
          const y = cy + Math.sin(angle) * radiusY;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle + Math.PI / 2);
          ctx.globalAlpha = 0.75 + 0.25 * Math.sin(time * 1.5 + i * 0.3);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      function draw(time) {
        ctx.clearRect(0, 0, width, height);
        drawBackground();
        drawBaseGlow();
        drawTotem(time);
        drawVivereRing(time);
      }

      let lastTime = 0;
      function loop(t) {
        if (!t) t = 0;
        const dt = (t - lastTime) / 1000;
        lastTime = t;

        const timeSec = t / 1000;

        const k = Math.min(1, dt * 5);
        viewScale += (targetViewScale - viewScale) * k;
        tiltX += (targetTiltX - tiltX) * k;
        tiltY += (targetTiltY - tiltY) * k;

        rotationY += autoRotate * dt; // teÄ = 0 â‡’ stojÃ­ na mÃ­stÄ›

        draw(timeSec);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---------- Interakce (drag + zoom) ----------

      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      function getPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;
      });

      window.addEventListener("mouseup", () => (dragging = false));

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const p = getPos(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        targetTiltY += dx * 0.004;
        targetTiltX += dy * 0.004;
        targetTiltX = Math.max(-1.4, Math.min(0.2, targetTiltX));
      });

      canvas.addEventListener(
        "touchstart",
        (e) => {
          dragging = true;
          const p = getPos(e);
          lastX = p.x;
          lastY = p.y;
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (!dragging) return;
          const p = getPos(e);
          const dx = p.x - lastX;
          const dy = p.y - lastY;
          lastX = p.x;
          lastY = p.y;

          targetTiltY += dx * 0.004;
          targetTiltX += dy * 0.004;
          targetTiltX = Math.max(-1.4, Math.min(0.2, targetTiltX));
        },
        { passive: false }
      );

      window.addEventListener(
        "touchend",
        () => {
          dragging = false;
        },
        { passive: false }
      );

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        let next = targetViewScale * factor;
        next = Math.max(0.7, Math.min(2.5, next));
        targetViewScale = next;
      });
    </script>
  </body>
</html>
