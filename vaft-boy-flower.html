<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Boy Flower Worlds</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);

        /* gradient + kluk vlevo dole ‚Äì cestu k PNG si m≈Ø≈æe≈° upravit */
        background:
          url("./img/vaft-boy.png") left 40px bottom 40px / auto 260px
            no-repeat,
          radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      #flower-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .title-bubble {
        position: absolute;
        left: 52%;
        top: 14%;
        transform: translateX(-50%);
        padding: 8px 16px;
        border-radius: 16px;
        background: #f8f1e5;
        color: #201310;
        font-size: 15px;
        font-weight: 600;
        line-height: 1.25;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(0, 0, 0, 0.15);
        text-align: center;
        pointer-events: none;
      }

      .title-bubble small {
        display: block;
        font-size: 10px;
        font-weight: 500;
        opacity: 0.7;
        margin-top: 2px;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="flower-canvas"></canvas>

        <div class="title-bubble">
          Vivere atque<br />FruiT
          <small>svƒõty rostouc√≠ z jednoho telefonu</small>
        </div>

        <div class="hud">
          üåÄ 1 prst / my≈° = ot√°ƒçen√≠ svƒõt≈Ø ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-right">
          v0.1 ‚Ä¢ VaF'i'T Boy Flower Worlds
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("flower-canvas");
      const ctx = canvas.getContext("2d");
      const dpr = window.devicePixelRatio || 1;

      let width = 0;
      let height = 0;

      // centr√°ln√≠ zoom pro planety
      let viewScale = 1;
      let targetViewScale = 1;

      // rotace planet
      let rotX = -0.35;
      let rotY = 0.4;

      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      let pinchActive = false;
      let pinchStartDist = 0;
      let pinchStartScale = 1;

      // layout ‚Äì telefon + planety
      const layout = {
        phone: { x: 0, y: 0 },
        planets: [
          { x: 0, y: 0, radius: 80, charOffset: 0 }, // hlavn√≠ naho≈ôe
          { x: 0, y: 0, radius: 58, charOffset: 40 },
          { x: 0, y: 0, radius: 52, charOffset: 80 },
        ],
      };

      function updateLayout() {
        // odhadnut√© pozice podle sc√©ny s klukem, m≈Ø≈æe≈° doladit
        const w = width;
        const h = height;

        layout.phone.x = w * 0.38;
        layout.phone.y = h * 0.63;

        layout.planets[0].x = layout.phone.x + 60;
        layout.planets[0].y = layout.phone.y - 240;

        layout.planets[1].x = layout.phone.x + 190;
        layout.planets[1].y = layout.phone.y - 260;

        layout.planets[2].x = layout.phone.x + 210;
        layout.planets[2].y = layout.phone.y - 150;
      }

      // ---------- P√çSMENKOV√â KOULE (≈°ablona) ----------

      const letterSource =
        "VIVEREATQUEFRUITMICHALKLIMEKHLAVOUNVIRIPIKOSREVIA" +
        "VAFITGLYPHCORENETWORKMAPAGUARDIANCHYBOZROUTFUELWORLD";
      const letters = letterSource.split("");

      const sphereTemplate = {
        points: [],
        aura: [],
        meridians: 34,
        parallels: 22,
      };

      function generateSphereTemplate() {
        const { meridians, parallels } = sphereTemplate;
        sphereTemplate.points = [];
        for (let j = 0; j <= parallels; j++) {
          const v = j / parallels;
          const lat = v * Math.PI - Math.PI / 2;
          for (let i = 0; i < meridians; i++) {
            const u = i / meridians;
            const lon = u * Math.PI * 2;
            const x = Math.cos(lat) * Math.cos(lon);
            const y = Math.sin(lat);
            const z = Math.cos(lat) * Math.sin(lon);
            sphereTemplate.points.push({
              x,
              y,
              z,
              phase: Math.random() * Math.PI * 2,
              charIndex: (i + j * meridians) % letters.length,
            });
          }
        }

        sphereTemplate.aura = [];
        for (let k = 0; k < 130; k++) {
          const lat = (Math.random() * Math.PI - Math.PI / 2) * 0.98;
          const lon = Math.random() * Math.PI * 2;
          const r = 1.05 + Math.random() * 0.1;
          const x = r * Math.cos(lat) * Math.cos(lon);
          const y = r * Math.sin(lat);
          const z = r * Math.cos(lat) * Math.sin(lon);
          sphereTemplate.aura.push({
            x,
            y,
            z,
            charIndex: k % letters.length,
            phase: Math.random() * Math.PI * 2,
          });
        }
      }

      function project3DLocal(x, y, z, cx, cy, radius) {
        // rotace kolem X
        let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
        let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
        // rotace kolem Y
        let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);

        const sx = cx + x2 * radius * viewScale;
        const sy = cy + y1 * radius * viewScale;
        return { sx, sy, z: z2 };
      }

      function drawLetterSphere(planet, time) {
        const { x: cx, y: cy, radius, charOffset } = planet;

        // glow za planetou
        ctx.save();
        const glowR = radius * 1.4 * viewScale;
        const gGlow = ctx.createRadialGradient(
          cx,
          cy - radius * 0.3 * viewScale,
          radius * 0.4 * viewScale,
          cx,
          cy,
          glowR
        );
        gGlow.addColorStop(0, "rgba(255,210,160,0.22)");
        gGlow.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = gGlow;
        ctx.fillRect(cx - glowR, cy - glowR, glowR * 2, glowR * 2);
        ctx.restore();

        // tƒõlo koule
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, radius * viewScale, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(
          cx - radius * 0.3 * viewScale,
          cy - radius * 0.4 * viewScale,
          radius * 0.4 * viewScale,
          cx,
          cy + radius * 0.5 * viewScale,
          radius * 1.2 * viewScale
        );
        grad.addColorStop(0, "#261713");
        grad.addColorStop(0.5, "#140c11");
        grad.addColorStop(1, "#040208");
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = "rgba(255, 197, 120, 0.9)";
        ctx.lineWidth = 1.4;
        ctx.shadowColor = "rgba(255, 197, 120, 0.9)";
        ctx.shadowBlur = 8;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();

        // p√≠smenka na povrchu
        ctx.save();
        ctx.font = `${9 * viewScale}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 220, 170, 0.98)";
        ctx.shadowColor = "rgba(255, 200, 150, 0.8)";
        ctx.shadowBlur = 6;

        for (const p of sphereTemplate.points) {
          const proj = project3DLocal(p.x, p.y, p.z, cx, cy, radius);
          if (proj.z < 0) continue;

          const flicker =
            0.6 + 0.4 * Math.sin(time * 1.4 + p.phase + proj.z * 2.0);
          ctx.globalAlpha = flicker;

          const ch =
            letters[(p.charIndex + charOffset) % letters.length] || "¬∑";
          ctx.fillText(ch, proj.sx, proj.sy);
        }

        // aura kolem
        ctx.font = `${8 * viewScale}px system-ui`;
        for (const p of sphereTemplate.aura) {
          const proj = project3DLocal(p.x, p.y, p.z, cx, cy, radius * 1.05);
          if (proj.z < 0) continue;
          const wobble = Math.sin(time * 2 + p.phase) * 2.5 * viewScale;
          const alpha = 0.25 + 0.45 * Math.sin(time * 1.6 + p.phase);
          ctx.globalAlpha = alpha;
          const ch =
            letters[(p.charIndex + charOffset) % letters.length] || "¬∑";
          ctx.fillText(ch, proj.sx, proj.sy + wobble);
        }

        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      function drawRingAround(planet, time) {
        const { x: cx, y: cy, radius } = planet;
        const ringText = "{*(¬∞.).)// Vivere atque FruiT \\\\(.(.¬∞)*}";
        const step = (Math.PI * 2) / ringText.length;
        const ringR = radius * 1.25 * viewScale;
        const ringTilt = -0.28;

        ctx.save();
        ctx.font = `${9 * viewScale}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 230, 185, 0.97)";
        ctx.shadowColor = "rgba(255, 210, 160, 0.9)";
        ctx.shadowBlur = 8;

        for (let i = 0; i < ringText.length; i++) {
          const ch = ringText[i];
          const angle = time * 0.4 + i * step;

          const x = Math.cos(angle);
          const y = Math.sin(angle) * Math.sin(ringTilt);
          const z = Math.sin(angle) * Math.cos(ringTilt);

          const proj = project3DLocal(x * 1.1, y * 1.1, z * 1.1, cx, cy, ringR);
          if (proj.z < 0) continue;

          const dir = angle + Math.PI / 2;
          ctx.save();
          ctx.translate(proj.sx, proj.sy);
          ctx.rotate(dir);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
        }

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // ---------- KRESLEN√ç STONKU / SIGN√ÅLU ----------

      function drawPhoneGlow() {
        const p = layout.phone;
        const baseR = Math.min(width, height) * 0.13;

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(
          p.x + 6,
          p.y + 32,
          baseR * 0.9,
          baseR * 0.35,
          0,
          0,
          Math.PI * 2
        );
        const g = ctx.createRadialGradient(
          p.x + 6,
          p.y + 12,
          baseR * 0.15,
          p.x + 6,
          p.y + 32,
          baseR * 1.1
        );
        g.addColorStop(0, "rgba(255,210,160,0.4)");
        g.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function drawStems(time) {
        ctx.save();
        ctx.lineWidth = 2.1;
        ctx.strokeStyle = "rgba(255, 214, 170, 0.9)";
        ctx.shadowColor = "rgba(255, 214, 170, 0.85)";
        ctx.shadowBlur = 15;
        ctx.lineCap = "round";

        const base = layout.phone;

        layout.planets.forEach((pl, idx) => {
          const sway = Math.sin(time * 0.4 + idx) * 16; // lehk√© vlnƒõn√≠
          const ctrlX = (base.x + pl.x) / 2 + (idx - 1) * 30 + sway;
          const ctrlY = Math.min(base.y, pl.y) - 70 - idx * 12;

          ctx.beginPath();
          ctx.moveTo(base.x + 12, base.y - 16);
          ctx.quadraticCurveTo(ctrlX, ctrlY, pl.x, pl.y + 6);
          ctx.stroke();
        });

        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // ---------- HLAVN√ç LOOP ----------

      function drawScene(time) {
        ctx.clearRect(0, 0, width, height);

        // jemn√Ω background glow kolem "rostliny"
        ctx.save();
        const cx = layout.phone.x + 120;
        const cy = layout.phone.y - 140;
        const r = Math.min(width, height) * 0.45;
        const bg = ctx.createRadialGradient(cx, cy, r * 0.1, cx, cy, r);
        bg.addColorStop(0, "rgba(40, 30, 50, 0.35)");
        bg.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = bg;
        ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
        ctx.restore();

        drawPhoneGlow();
        drawStems(time);

        // planety
        for (let i = 0; i < layout.planets.length; i++) {
          drawLetterSphere(layout.planets[i], time);
        }

        // prstenec kolem hlavn√≠ planety
        drawRingAround(layout.planets[0], time);
      }

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        updateLayout();
      }

      generateSphereTemplate();
      resize();
      window.addEventListener("resize", resize);

      let lastTime = 0;
      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const t = timestamp / 1000;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        viewScale += (targetViewScale - viewScale) * Math.min(1, dt * 5);
        rotY += dt * 0.16; // jemn√° auto-rotace

        drawScene(t);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // ---------- INTERAKCE ----------

      function getPos(e) {
        if (e.touches && e.touches.length > 0) {
          return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        return { x: e.clientX, y: e.clientY };
      }

      canvas.addEventListener("mousedown", (e) => {
        dragging = true;
        const p = getPos(e);
        lastX = p.x;
        lastY = p.y;
      });

      window.addEventListener("mouseup", () => {
        dragging = false;
      });

      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const p = getPos(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        rotY += dx * 0.008;
        rotX += dy * 0.008;
        rotX = Math.max(-Math.PI / 2 + 0.15, Math.min(Math.PI / 2 - 0.15, rotX));
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.9 : 1.1;
          targetViewScale = Math.max(0.6, Math.min(2.5, viewScale * factor));
        },
        { passive: false }
      );

      // dotyk
      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (e.touches.length === 2) {
            pinchActive = true;
            dragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchStartDist = Math.hypot(dx, dy);
            pinchStartScale = viewScale;
          } else if (e.touches.length === 1) {
            pinchActive = false;
            dragging = true;
            const p = getPos(e);
            lastX = p.x;
            lastY = p.y;
          }
        },
        { passive: false }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (pinchActive && e.touches.length === 2) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const ratio = dist / pinchStartDist;
            targetViewScale = Math.max(
              0.6,
              Math.min(2.5, pinchStartScale * ratio)
            );
            return;
          }
          if (dragging && e.touches.length === 1) {
            e.preventDefault();
            const p = getPos(e);
            const dx = p.x - lastX;
            const dy = p.y - lastY;
            lastX = p.x;
            lastY = p.y;
            rotY += dx * 0.008;
            rotX += dy * 0.008;
            rotX = Math.max(
              -Math.PI / 2 + 0.15,
              Math.min(Math.PI / 2 - 0.15, rotX)
            );
          }
        },
        { passive: false }
      );

      window.addEventListener("touchend", () => {
        dragging = false;
        pinchActive = false;
      });
    </script>
  </body>
</html>
