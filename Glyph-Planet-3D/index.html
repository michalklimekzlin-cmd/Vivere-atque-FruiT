<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Glyph Planet 3D</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      #scene-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 16px;
        bottom: 12px;
        font-size: 10px;
        opacity: 0.8;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.8;
      }

      .hud-center {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        opacity: 0.9;
        text-align: center;
        white-space: nowrap;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="scene-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = ot√°ƒçen√≠ Glyph-planety ‚Ä¢ 2 prsty / koleƒçko = zoom
        </div>

        <div class="hud-center">
          Glyph planeta: hvƒõzdn√© oko ‚Ä¢ √∫smƒõv ‚Ä¢ ochrann√Ω prstenec
        </div>

        <div class="hud-right">v0.1 ‚Ä¢ VaF'i'T Glyph Planet 3D</div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js";

      // (--- ZBYTEK K√ìDU JE STEJN√ù ---)
   
    const canvas = document.getElementById("scene-canvas");

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setClearColor(0x000000, 0);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
      camera.position.set(0, 1.2, 10);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.rotateSpeed = 0.8;
      controls.enablePan = false;
      controls.minDistance = 5;
      controls.maxDistance = 14;

      // svƒõtla
      scene.add(new THREE.AmbientLight(0xffe0c0, 0.45));

      const dirLight = new THREE.DirectionalLight(0xfff0d0, 1.1);
      dirLight.position.set(4, 6, 3);
      scene.add(dirLight);

      const rimLight = new THREE.DirectionalLight(0xffcc88, 0.7);
      rimLight.position.set(-5, 3, -4);
      scene.add(rimLight);

      // z√°kladn√≠ materi√°ly
      const goldMat = new THREE.MeshStandardMaterial({
        color: 0xffd4a0,
        emissive: 0xffb060,
        emissiveIntensity: 0.75,
        metalness: 0.5,
        roughness: 0.25,
      });

      const lineMat = new THREE.LineBasicMaterial({
        color: 0xffe8c0,
        linewidth: 1,
      });

      const glyphGroup = new THREE.Group();
      scene.add(glyphGroup);

      // --- HLAVA ---
      const headGeom = new THREE.BoxGeometry(3.2, 3.6, 1.3);
      headGeom.translate(0, 0.4, 0);
      const head = new THREE.Mesh(headGeom, goldMat);
      glyphGroup.add(head);

      const headEdges = new THREE.LineSegments(
        new THREE.EdgesGeometry(headGeom),
        lineMat
      );
      glyphGroup.add(headEdges);

      // lehk√© zaoblen√≠: p≈ôid√°me "helmet" oblouk naho≈ôe
      const helmGeom = new THREE.TorusGeometry(2.1, 0.09, 16, 80, Math.PI);
      const helm = new THREE.Mesh(helmGeom, goldMat);
      helm.rotation.z = Math.PI;
      helm.position.set(0, 2.1, 0.65);
      glyphGroup.add(helm);

      // --- OƒåI ---
      const eyeGeom = new THREE.SphereGeometry(0.55, 24, 24);
      const eyeMat = new THREE.MeshStandardMaterial({
        color: 0xfff5dd,
        emissive: 0xffd48a,
        emissiveIntensity: 0.8,
        metalness: 0.2,
        roughness: 0.1,
      });

      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-0.4, 0.7, 0.66);
      glyphGroup.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(0.6, 0.5, 0.66);
      rightEye.scale.set(0.9, 0.9, 0.9);
      glyphGroup.add(rightEye);

      // hvƒõzdn√© oko ‚Äì extrudovan√° hvƒõzda
      function createStarMesh(radiusOuter, radiusInner, depth) {
        const shape = new THREE.Shape();
        const spikes = 5;
        let rot = Math.PI / 2 * -1;
        const step = Math.PI / spikes;

        shape.moveTo(
          Math.cos(rot) * radiusOuter,
          Math.sin(rot) * radiusOuter
        );
        for (let i = 0; i < spikes; i++) {
          rot += step;
          shape.lineTo(
            Math.cos(rot) * radiusInner,
            Math.sin(rot) * radiusInner
          );
          rot += step;
          shape.lineTo(
            Math.cos(rot) * radiusOuter,
            Math.sin(rot) * radiusOuter
          );
        }

        const extrudeSettings = {
          depth,
          bevelEnabled: false,
        };
        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        return new THREE.Mesh(geo, goldMat);
      }

      const starEye = createStarMesh(0.35, 0.17, 0.08);
      starEye.rotation.y = -Math.PI / 2;
      starEye.position.set(-1.35, 1.0, 0.7);
      glyphGroup.add(starEye);

      // mal√© svƒõt√©lko pod okem
      const smallDotGeom = new THREE.SphereGeometry(0.2, 20, 20);
      const smallDot = new THREE.Mesh(smallDotGeom, eyeMat);
      smallDot.position.set(0.2, 0.05, 0.69);
      glyphGroup.add(smallDot);

      const smallDot2 = smallDot.clone();
      smallDot2.position.set(0.95, -0.05, 0.69);
      glyphGroup.add(smallDot2);

      // --- √öSMƒöV / M≈ò√ç≈ΩKA ---
      const mouthGeom = new THREE.BoxGeometry(1.9, 0.55, 0.1);
      const mouth = new THREE.Mesh(mouthGeom, goldMat);
      mouth.position.set(0.2, -0.9, 0.67);
      glyphGroup.add(mouth);

      const mouthLines = new THREE.Group();
      const barMat = goldMat;

      // vertik√°ln√≠ sloupky
      const vBarGeom = new THREE.BoxGeometry(0.06, 0.52, 0.06);
      const xOffsets = [-0.7, -0.35, 0, 0.35, 0.7];
      xOffsets.forEach((x) => {
        const bar = new THREE.Mesh(vBarGeom, barMat);
        bar.position.set(x + 0.2, -0.9, 0.72);
        mouthLines.add(bar);
      });

      // horizont√°ln√≠ linky
      const hBarGeom = new THREE.BoxGeometry(1.9, 0.06, 0.06);
      const yOffsets = [-0.75, -0.9, -1.05];
      yOffsets.forEach((y) => {
        const bar = new THREE.Mesh(hBarGeom, barMat);
        bar.position.set(0.2, y, 0.72);
        mouthLines.add(bar);
      });

      glyphGroup.add(mouthLines);

      // --- OCHRANN√ù PRSTENEC / PL√Å≈†≈§ ---
      const ringGeom = new THREE.TorusGeometry(4.1, 0.08, 16, 120, Math.PI * 1.4);
      const ring = new THREE.Mesh(ringGeom, goldMat);
      ring.rotation.set(Math.PI * 0.5, 0, Math.PI * 0.05);
      ring.position.set(0, -0.1, 0);
      glyphGroup.add(ring);

      // vnit≈ôn√≠ m≈ô√≠≈æka prstence (dr√°tƒõn√Ω ko≈°)
      const basketGroup = new THREE.Group();
      const basketRadius = 3.1;
      const basketHeight = 2.5;
      const segments = 10;

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const angle = -Math.PI * 0.8 + t * Math.PI * 1.6;
        const x = Math.cos(angle) * basketRadius;
        const z = Math.sin(angle) * basketRadius;
        const lineGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(x, -1.4, z),
          new THREE.Vector3(x * 0.25, -1.4 - basketHeight, z * 0.25),
        ]);
        const line = new THREE.Line(lineGeo, lineMat);
        basketGroup.add(line);
      }

      for (let j = 0; j <= 6; j++) {
        const h = -1.4 - (basketHeight * j) / 6;
        const ringGeo2 = new THREE.BufferGeometry();
        const points = [];
        for (let i = 0; i <= 60; i++) {
          const t = i / 60;
          const angle = -Math.PI * 0.8 + t * Math.PI * 1.6;
          const r = THREE.MathUtils.lerp(basketRadius, basketRadius * 0.25, j / 6);
          points.push(
            new THREE.Vector3(
              Math.cos(angle) * r,
              h,
              Math.sin(angle) * r
            )
          );
        }
        ringGeo2.setFromPoints(points);
        const line = new THREE.Line(ringGeo2, lineMat);
        basketGroup.add(line);
      }

      glyphGroup.add(basketGroup);

      // z√°kladn√≠ podklad / st√≠n pod planetou
      const shadowGeo = new THREE.CircleGeometry(4.5, 64);
      const shadowMat = new THREE.MeshBasicMaterial({
        color: 0x050302,
        transparent: true,
        opacity: 0.85,
      });
      const shadow = new THREE.Mesh(shadowGeo, shadowMat);
      shadow.rotation.x = -Math.PI / 2;
      shadow.position.y = -3.5;
      scene.add(shadow);

      // nastaven√≠ cel√© planety
      glyphGroup.position.set(0, 0.2, 0);
      glyphGroup.rotation.set(0.1, -0.6, 0);

      // --- RESIZE ---
      function onResize() {
        const rect = canvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }

      window.addEventListener("resize", onResize);
      onResize();

      // --- ANIMACE ---
      let lastTime = 0;
      function animate(timestamp = 0) {
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        glyphGroup.rotation.y += dt * 0.35; // vlastn√≠ pomal√© ot√°ƒçen√≠
        glyphGroup.rotation.x = 0.15 + Math.sin(timestamp * 0.0005) * 0.08;

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
