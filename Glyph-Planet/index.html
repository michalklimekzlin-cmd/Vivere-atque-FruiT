<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Glyph Planet</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #glyph-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-center {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        opacity: 0.85;
        text-align: center;
        white-space: nowrap;
      }
    </style>
  </head>
  <body>
    <div class="root">
      <div class="stage">
        <canvas id="glyph-canvas"></canvas>
        <div class="hud">
          üåÄ 1 prst / my≈° = ot√°ƒçen√≠ Glyph-planety ‚Ä¢ 2 prsty / koleƒçko = zoom
        </div>
        <div class="hud-center">
          Glyph planeta: hvƒõzdn√© oko ‚Ä¢ √∫smƒõv ‚Ä¢ ochrann√Ω prstenec
        </div>
        <div class="hud-right">v0.1 ‚Ä¢ VaF'i'T Glyph Planet</div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("glyph-canvas");
      const ctx = canvas.getContext("2d");

      let width = 0;
      let height = 0;
      const dpr = window.devicePixelRatio || 1;

      let viewScale = 1.2;
      let targetViewScale = 1.2;

      let rotX = 0.22;   // m√≠rn√Ω n√°klon dol≈Ø
      let rotY = -0.5;   // natoƒçen√≠ lehce zleva
      let targetRotX = rotX;
      let targetRotY = rotY;

      const cameraDist = 6;   // ‚Äûvzd√°lenost kamery‚Äú
      let autoSpin = 0.35;    // automatick√© ot√°ƒçen√≠ kolem Y

      // MODEL GLYPH PLANETY ---------------------------------------------------

      /*
        Model prostor: x,y,z v rozsahu cca [-2, 2]
        V≈°echny tvary jsou tenk√° ‚Äûplacka‚Äú kolem z‚âà0, 3D efekt d√°v√° rotace + perspektiva.
      */

      /** Vr√°t√≠ pole bod≈Ø elipsy */
      function buildEllipse(cx, cy, rx, ry, segs = 64, z = 0) {
        const pts = [];
        for (let i = 0; i <= segs; i++) {
          const t = (i / segs) * Math.PI * 2;
          pts.push({
            x: cx + Math.cos(t) * rx,
            y: cy + Math.sin(t) * ry,
            z
          });
        }
        return pts;
      }

      /** Hvƒõzda pro oko */
      function buildStar(cx, cy, rOuter, rInner, points = 5, z = 0.02) {
        const pts = [];
        for (let i = 0; i <= points * 2; i++) {
          const r = i % 2 === 0 ? rOuter : rInner;
          const a = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
          pts.push({
            x: cx + Math.cos(a) * r,
            y: cy + Math.sin(a) * r,
            z
          });
        }
        return pts;
      }

      /** Jednoduch√Ω zaoblen√Ω ‚Äûbublinov√Ω‚Äú obliƒçej */
      function buildFaceOutline() {
        const pts = [];
        const top = -0.85;
        const bottom = 0.9;
        const left = -0.6;
        const right = 0.8;

        const seg = 20;

        // horn√≠ oblouk
        for (let i = 0; i <= seg; i++) {
          const t = i / seg;
          const a = Math.PI * (1 + t); // od 180¬∞ do 360¬∞
          pts.push({
            x: (left + right) / 2 + Math.cos(a) * (right - left) / 2,
            y: top + Math.sin(a) * 0.45,
            z: 0.01
          });
        }

        // prav√Ω bok dol≈Ø
        for (let i = 0; i <= seg; i++) {
          const t = i / seg;
          pts.push({
            x: right,
            y: top + t * (bottom - top),
            z: 0.01
          });
        }

        // spodn√≠ oblouk
        for (let i = 0; i <= seg; i++) {
          const t = i / seg;
          const a = Math.PI * (t); // 0¬∞ a≈æ 180¬∞
          pts.push({
            x: (left + right) / 2 + Math.cos(a) * (right - left) * 0.55,
            y: bottom + Math.sin(a) * 0.35,
            z: 0.01
          });
        }

        // ‚Äû≈°piƒçat√Ω nos‚Äú doleva
        pts.push({ x: left - 0.35, y: (top + bottom) / 2, z: 0.01 });

        // zpƒõt nahoru k v√Ωchoz√≠mu bodu
        pts.push(pts[0]);
        return pts;
      }

      /** Vl√°sky / kapuce kolem hlavy */
      function buildHood() {
        const pts = [];
        const seg = 40;
        const cx = -0.2;
        const cy = 0;
        const rx = 2.0;
        const ry = 1.45;

        // vnƒõj≈°√≠ oblouk
        for (let i = 0; i <= seg; i++) {
          const t = i / seg;
          const a = Math.PI * (0.15 + 0.7 * t); // od spodku vlevo nahoru doprava
          pts.push({
            x: cx + Math.cos(a) * rx,
            y: cy + Math.sin(a) * ry,
            z: -0.03
          });
        }

        // vnit≈ôn√≠ oblouk zpƒõt
        for (let i = seg; i >= 0; i--) {
          const t = i / seg;
          const a = Math.PI * (0.18 + 0.7 * t);
          pts.push({
            x: cx + Math.cos(a) * (rx - 0.45),
            y: cy + Math.sin(a) * (ry - 0.45),
            z: -0.03
          });
        }

        return pts;
      }

      /** M≈ô√≠≈æka na kapuci ‚Äì nƒõkolik ‚Äûpod√©ln√Ωch‚Äú a ‚Äûp≈ô√≠ƒçn√Ωch‚Äú ƒçar */
      function buildHoodGrid() {
        const lines = [];
        const cx = -0.2;
        const cy = 0;
        const rx = 2.0;
        const ry = 1.45;

        const cols = 4;
        const rows = 5;

        // pod√©ln√© pruhy
        for (let c = -cols; c <= cols; c++) {
          const tOffset = c / (cols + 0.5);
          const pts = [];
          for (let i = 0; i <= 32; i++) {
            const t = i / 32;
            const a = Math.PI * (0.18 + 0.7 * t);
            pts.push({
              x: cx + Math.cos(a) * (rx - 0.1 + 0.25 * tOffset),
              y: cy + Math.sin(a) * (ry - 0.1 + 0.15 * tOffset),
              z: -0.02
            });
          }
          lines.push(pts);
        }

        // p≈ô√≠ƒçn√© pruhy
        for (let r = 1; r <= rows; r++) {
          const v = r / (rows + 1);
          const pts = [];
          for (let i = 0; i <= 28; i++) {
            const t = i / 28;
            const a = Math.PI * (0.2 + 0.65 * t);
            const rr = 1.5 + 0.35 * Math.sin(v * Math.PI);
            pts.push({
              x: cx + Math.cos(a) * rr,
              y: cy + Math.sin(a) * rr * 0.8,
              z: -0.02
            });
          }
          lines.push(pts);
        }

        return lines;
      }

      function buildMouthGrid() {
        const lines = [];
        const top = 0.55;
        const bottom = 0.78;
        const left = -0.15;
        const right = 0.7;

        const cols = 6;
        const rows = 3;

        // horizont√°ln√≠
        for (let r = 0; r <= rows; r++) {
          const y = top + ((bottom - top) * r) / rows;
          const pts = [];
          for (let c = 0; c <= cols; c++) {
            const x = left + ((right - left) * c) / cols;
            pts.push({ x, y, z: 0.015 });
          }
          lines.push(pts);
        }

        // vertik√°ln√≠
        for (let c = 0; c <= cols; c++) {
          const x = left + ((right - left) * c) / cols;
          const pts = [];
          for (let r = 0; r <= rows; r++) {
            const y = top + ((bottom - top) * r) / rows;
            pts.push({ x, y, z: 0.015 });
          }
          lines.push(pts);
        }

        return lines;
      }

      const model = {
        hood: null,
        hoodGrid: null,
        faceOutline: null,
        eyeMain: null,
        eyeRight: null,
        starEye: null,
        cheeks: [],
        mouthLines: null,
        browLines: []
      };

      function buildModel() {
        model.hood = buildHood();
        model.hoodGrid = buildHoodGrid();
        model.faceOutline = buildFaceOutline();
        model.eyeMain = buildEllipse(0.25, -0.15, 0.35, 0.6, 42, 0.03);
        model.eyeRight = buildEllipse(0.65, -0.05, 0.18, 0.35, 36, 0.03);
        model.starEye = buildStar(-0.05, -0.15, 0.22, 0.09, 5, 0.04);

        model.cheeks = [
          { x: 0.24, y: 0.25, r: 0.11, z: 0.03 },
          { x: 0.72, y: 0.28, r: 0.11, z: 0.03 }
        ];

        model.mouthLines = buildMouthGrid();

        // ‚Äûofiny‚Äú / prameny vlas≈Ø p≈ôed obliƒçejem
        const brow1 = [];
        const brow2 = [];
        const brow3 = [];
        for (let i = 0; i <= 24; i++) {
          const t = i / 24;
          const yy = -1.2 + t * 1.5;
          brow1.push({ x: 1.1 + Math.sin(t * Math.PI) * 0.3, y: yy, z: 0.08 });
          brow2.push({
            x: 1.3 + Math.sin(t * Math.PI) * 0.25,
            y: yy + 0.05,
            z: 0.09
          });
          brow3.push({
            x: 1.5 + Math.sin(t * Math.PI) * 0.2,
            y: yy + 0.1,
            z: 0.1
          });
        }
        model.browLines = [brow1, brow2, brow3];
      }

      buildModel();

      // PROJEKCE ---------------------------------------------------------------

      function projectPoint(p) {
        const sx = p.x;
        const sy = p.y;
        const sz = p.z;

        // rotace kolem X
        let y1 = sy * Math.cos(rotX) - sz * Math.sin(rotX);
        let z1 = sy * Math.sin(rotX) + sz * Math.cos(rotX);

        // rotace kolem Y
        let x2 = sx * Math.cos(rotY) + z1 * Math.sin(rotY);
        let z2 = -sx * Math.sin(rotY) + z1 * Math.cos(rotY);

        const dist = cameraDist;
        const k = dist / (dist - z2);
        return {
          x: x2 * k * baseScale + width / 2,
          y: y1 * k * baseScale + height / 2,
          depth: z2
        };
      }

      let baseScale = 120; // p≈ôep√≠≈°e se v resize

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        baseScale = Math.min(width, height) * 0.16;
      }

      resize();
      window.addEventListener("resize", resize);

      // KRESLEN√ç ----------------------------------------------------------------

      function strokePath(points, alpha = 1, width = 1.4) {
        if (!points || points.length === 0) return;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = width;
        ctx.beginPath();
        let p0 = projectPoint(points[0]);
        ctx.moveTo(p0.x, p0.y);
        for (let i = 1; i < points.length; i++) {
          const p = projectPoint(points[i]);
          ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      function drawScene(dt) {
        ctx.clearRect(0, 0, width, height);

        // m√≠rn√Ω z√°≈ôiv√Ω kruh pod hlavou
        ctx.save();
        const cx = width / 2;
        const cy = height / 2 + baseScale * 1.4;
        const r = baseScale * 1.3;
        ctx.beginPath();
        const g = ctx.createRadialGradient(
          cx,
          cy,
          r * 0.1,
          cx,
          cy,
          r * 1.1
        );
        g.addColorStop(0, "rgba(20,12,8,0.7)");
        g.addColorStop(1, "rgba(0,0,0,0.0)");
        ctx.fillStyle = g;
        ctx.ellipse(cx, cy, r, r * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        // spodn√≠ kapuce grid ‚Äì tlumenƒõj≈°√≠
        ctx.strokeStyle = "rgba(255, 210, 150, 0.4)";
        for (const line of model.hoodGrid) {
          strokePath(line, 0.6, 0.9);
        }

        // hlavn√≠ kapuce
        ctx.strokeStyle = "rgba(255, 216, 160, 0.95)";
        ctx.shadowColor = "rgba(255, 200, 130, 0.6)";
        ctx.shadowBlur = 8;
        strokePath(model.hood, 1, 1.8);
        ctx.shadowBlur = 0;

        // obliƒçej ‚Äì outline
        ctx.strokeStyle = "rgba(255, 220, 170, 0.96)";
        strokePath(model.faceOutline, 1, 1.6);

        // √∫sta ‚Äì m≈ô√≠≈æka
        ctx.strokeStyle = "rgba(255, 210, 150, 0.9)";
        for (const line of model.mouthLines) {
          strokePath(line, 0.9, 1.1);
        }

        // hlavn√≠ oko
        ctx.strokeStyle = "rgba(255, 230, 185, 0.98)";
        strokePath(model.eyeMain, 1, 1.8);

        // druh√© oko
        strokePath(model.eyeRight, 0.9, 1.4);

        // star-oko
        strokePath(model.starEye, 1, 1.6);

        // tv√°≈ôiƒçky
        ctx.fillStyle = "rgba(255, 210, 160, 0.9)";
        ctx.strokeStyle = "rgba(255, 230, 190, 1)";
        for (const c of model.cheeks) {
          const pc = projectPoint(c);
          const r = c.r * baseScale * (cameraDist / (cameraDist - pc.depth));
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.arc(pc.x, pc.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.beginPath();
          ctx.arc(pc.x, pc.y, r, 0, Math.PI * 2);
          ctx.stroke();
        }

        // ofiny / vlasy
        ctx.strokeStyle = "rgba(255, 220, 160, 0.95)";
        ctx.shadowColor = "rgba(255, 200, 140, 0.7)";
        ctx.shadowBlur = 10;
        for (const line of model.browLines) {
          strokePath(line, 1, 2);
        }
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      // ANIMACE -----------------------------------------------------------------

      let lastTime = 0;
      function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        // auto spin
        rotY += autoSpin * dt;

        // easing k c√≠lov√Ωm rotac√≠m / zoomu
        const k = Math.min(1, 6 * dt);
        rotX += (targetRotX - rotX) * k;
        rotY += (targetRotY - rotY) * k;
        viewScale += (targetViewScale - viewScale) * k;

        drawScene(dt);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      // INTERAKCE --------------------------------------------------------------

      let dragging = false;
      let lastX = 0;
      let lastY = 0;
      let startRotX = 0;
      let startRotY = 0;

      // pinch
      let pinchDist = 0;
      let startScale = 1;

      function onPointerDown(e) {
        e.preventDefault();
        if (e.touches && e.touches.length === 2) {
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const dx = t0.clientX - t1.clientX;
          const dy = t0.clientY - t1.clientY;
          pinchDist = Math.hypot(dx, dy);
          startScale = targetViewScale;
          dragging = false;
          return;
        }

        const touch = e.touches ? e.touches[0] : e;
        dragging = true;
        lastX = touch.clientX;
        lastY = touch.clientY;
        startRotX = targetRotX;
        startRotY = targetRotY;
      }

      function onPointerMove(e) {
        if (e.touches && e.touches.length === 2) {
          e.preventDefault();
          const t0 = e.touches[0];
          const t1 = e.touches[1];
          const dx = t0.clientX - t1.clientX;
          const dy = t0.clientY - t1.clientY;
          const dist = Math.hypot(dx, dy);
          if (!pinchDist) pinchDist = dist;
          const ratio = dist / pinchDist;
          targetViewScale = Math.max(0.7, Math.min(2.5, startScale * ratio));
          return;
        }

        if (!dragging) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const dx = touch.clientX - lastX;
        const dy = touch.clientY - lastY;

        targetRotY = startRotY + dx * 0.01;
        targetRotX = startRotX + dy * 0.01;
        targetRotX = Math.max(-1.2, Math.min(1.2, targetRotX));
        autoSpin = 0.0; // p≈ôi ruƒçn√≠m pohybu automatiku utlum√≠me
      }

      function onPointerUp() {
        dragging = false;
        autoSpin = 0.2; // lehk√Ω auto spin zpƒõt
        pinchDist = 0;
      }

      canvas.addEventListener("mousedown", onPointerDown);
      window.addEventListener("mousemove", onPointerMove);
      window.addEventListener("mouseup", onPointerUp);
      window.addEventListener("contextmenu", e => e.preventDefault());

      canvas.addEventListener("touchstart", onPointerDown, { passive: false });
      window.addEventListener("touchmove", onPointerMove, { passive: false });
      window.addEventListener("touchend", onPointerUp, { passive: false });
      window.addEventListener("touchcancel", onPointerUp, { passive: false });

      canvas.addEventListener("wheel", e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        targetViewScale = Math.max(
          0.7,
          Math.min(2.5, targetViewScale * factor)
        );
      });
    </script>
  </body>
</html>
