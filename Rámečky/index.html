<!doctype html>
<html lang="cs">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VaF'i'T ‚Ä¢ Signal Core ‚Äì R√°meƒçky</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #050815, #020208);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color: #f5f5f5;
      }

      .root {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .stage {
        position: relative;
        width: min(920px, 96vw);
        height: min(620px, 90vh);
        border-radius: 32px;
        box-shadow: 0 40px 90px rgba(0, 0, 0, 0.85);
        background: radial-gradient(circle at top, #06091a, #020208);
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      #signal-canvas {
        position: absolute;
        inset: 0;
        margin: auto;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 10px;
        opacity: 0.75;
      }

      .hud-center {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        font-size: 11px;
        opacity: 0.85;
        white-space: nowrap;
      }

      .hud-right {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 10px;
        opacity: 0.75;
      }
    </style>
  </head>

  <body>
    <div class="root">
      <div class="stage">
        <canvas id="signal-canvas"></canvas>

        <div class="hud">
          üåÄ 1 prst / my≈° = n√°klon ‚Ä¢ ≈•uk / klik = zmƒõna re≈æimu ‚Ä¢ pinch / koleƒçko = zoom
        </div>
        <div class="hud-center" id="mode-label">
          re≈æim: s√≠≈• r√°meƒçk≈Ø
        </div>
        <div class="hud-right">v0.2 ‚Ä¢ VaF'i'T Signal Core ‚Äì R√°meƒçky</div>
      </div>
    </div>

    <script>
      // ÔΩ°*Ôæü‚ú≤*‚òÜ VaF'i'T SignalCore ‚Äì 3D r√°meƒçky m√≠sto koule ‚òÜ*‚ú≤Ôæü*ÔΩ°

      const canvas = document.getElementById("signal-canvas");
      const ctx = canvas.getContext("2d");
      const modeLabel = document.getElementById("mode-label");

      const dpr = window.devicePixelRatio || 1;
      let width = 0;
      let height = 0;

      // ‚Äûkamera‚Äú
      let viewScale = 1.2;
      let targetViewScale = 1.2;
      let viewOffsetX = 0;
      let viewOffsetY = 40;

      // z√°kladn√≠ rozmƒõry sc√©nky
      let baseRadius = 120;
      let coneHeight = 200;

      // n√°klon sc√©ny
      let tiltX = 1.0;
      let tiltY = 0.0;
      let targetTiltX = tiltX;
      let targetTiltY = tiltY;

      // re≈æimy zobrazen√≠
      const modes = ["mesh", "letters", "glyph", "vafiti"];
      let modeIndex = 0;

      const glyphs = ["\\{*(¬∞‚Ä¢.)(.‚Ä¢¬∞)*}//", "Ÿã&‚Äô„Äç", "{¬∞\"(.).),,(\\/ )¬°¬°(\\/),,,(.(.)\"¬∞}"];
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

      // m√≠sto bod≈Ø m√°me sadu 3D r√°meƒçk≈Ø (krabic bez v√Ωplnƒõ)
      const signalCore = {
        frames: [],
        frameCount: 6,
        pulse: 0
      };

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        baseRadius = Math.min(width, height) * 0.19;
        coneHeight = baseRadius * 1.6;

        generateFrames();
      }

      // vytvo≈ôen√≠ r√°meƒçk≈Ø v prostoru (v√≠ce kus≈Ø nad sebou)
      function generateFrames() {
        signalCore.frames = [];
        const n = signalCore.frameCount;

        for (let i = 0; i < n; i++) {
          const t = n === 1 ? 0.5 : i / (n - 1); // 0..1
          const y = -coneHeight / 2 + t * coneHeight;

          const size = baseRadius * (0.8 + 0.5 * t); // naho≈ôe o nƒõco vƒõt≈°√≠
          const depth = baseRadius * 0.28; // ‚Äûtlou≈°≈•ka‚Äú r√°meƒçku

          signalCore.frames.push({
            y,
            w: size,
            h: size * 0.7,
            d: depth,
            phase: Math.random() * Math.PI * 2
          });
        }
      }

      // 3D -> 2D projekce (vyu≈æ√≠v√°me stejn√© parametry jako p≈Øvodnƒõ)
      function projectPoint(x, y, z) {
        const sinX = Math.sin(tiltX);
        const cosX = Math.cos(tiltX);
        const sinY = Math.sin(tiltY);
        const cosY = Math.cos(tiltY);

        // rotace kolem X
        const y1 = y * cosX - z * sinX;
        const z1 = y * sinX + z * cosX;

        // rotace kolem Y
        const x2 = x * cosY + z1 * sinY;
        const z2 = -x * sinY + z1 * cosY;

        const sx = (width / 2 + viewOffsetX) + x2 * viewScale;
        const sy = (height / 2 + viewOffsetY) + y1 * viewScale;

        return { x: sx, y: sy, z: z2 };
      }

      function drawBackground() {
        ctx.clearRect(0, 0, width, height);

        // jemn√© svƒõtlo zdola
        const g = ctx.createRadialGradient(
          width / 2,
          height / 2 + 120,
          0,
          width / 2,
          height / 2 + 120,
          baseRadius * 3
        );
        g.addColorStop(0, "rgba(255, 210, 160, 0.22)");
        g.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);

        // spodn√≠ elipsa / podstavec
        ctx.save();
        ctx.translate(width / 2 + viewOffsetX, height / 2 + viewOffsetY);
        ctx.scale(viewScale, viewScale);
        ctx.beginPath();
        ctx.ellipse(
          0,
          coneHeight / 2 + 10,
          baseRadius * 1.05,
          baseRadius * 0.35,
          0,
          0,
          Math.PI * 2
        );
        const eGrad = ctx.createRadialGradient(
          0,
          coneHeight / 2 + 10,
          baseRadius * 0.1,
          0,
          coneHeight / 2 + 10,
          baseRadius * 1.1
        );
        eGrad.addColorStop(0, "rgba(20,12,8,1)");
        eGrad.addColorStop(1, "rgba(0,0,0,0.6)");
        ctx.fillStyle = eGrad;
        ctx.fill();
        ctx.restore();
      }

      // pomocn√°: vr√°t√≠ projekci st≈ôedu r√°meƒçku v Y pro glow ku≈æele
      function getFrameCenterScreenY(index) {
        const f = signalCore.frames[index];
        if (!f) return height / 2 + viewOffsetY;
        const p = projectPoint(0, f.y, 0);
        return p.y;
      }

      // nakreslen√≠ dr√°tƒõn√©ho 3D r√°meƒçku z hraniƒçn√≠ch bod≈Ø
      function drawFrameWire(frame) {
        const hw = frame.w / 2;
        const hh = frame.h / 2;
        const hd = frame.d / 2;
        const cy = frame.y;

        // 8 roh≈Ø krabice
        const corners3D = [
          { x: -hw, y: cy - hh, z: -hd }, // 0 front-top-left
          { x: hw, y: cy - hh, z: -hd }, // 1 front-top-right
          { x: hw, y: cy + hh, z: -hd }, // 2 front-bottom-right
          { x: -hw, y: cy + hh, z: -hd }, // 3 front-bottom-left
          { x: -hw, y: cy - hh, z: hd }, // 4 back-top-left
          { x: hw, y: cy - hh, z: hd }, // 5 back-top-right
          { x: hw, y: cy + hh, z: hd }, // 6 back-bottom-right
          { x: -hw, y: cy + hh, z: hd } // 7 back-bottom-left
        ];

        const pts = corners3D.map((p) => projectPoint(p.x, p.y, p.z));

        const edges = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 0],
          [4, 5],
          [5, 6],
          [6, 7],
          [7, 4],
          [0, 4],
          [1, 5],
          [2, 6],
          [3, 7]
        ];

        ctx.beginPath();
        for (const [a, b] of edges) {
          ctx.moveTo(pts[a].x, pts[a].y);
          ctx.lineTo(pts[b].x, pts[b].y);
        }
        ctx.stroke();
      }

      function drawMeshMode() {
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = "rgba(255, 210, 150, 0.9)";
        ctx.shadowColor = "rgba(255, 180, 130, 0.7)";
        ctx.shadowBlur = 10;

        for (const frame of signalCore.frames) {
          drawFrameWire(frame);
        }

        ctx.shadowBlur = 0;
      }

      function drawLettersMode() {
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 220, 170, 0.95)";
        ctx.shadowColor = "rgba(255, 200, 140, 0.7)";
        ctx.shadowBlur = 6;

        const len = letters.length;
        let index = 0;

        for (const frame of signalCore.frames) {
          const hw = frame.w / 2;
          const hh = frame.h / 2;
          const hd = frame.d / 2;
          const cy = frame.y;

          // ƒçty≈ôi st≈ôedy hran ‚Äûp≈ôedn√≠ho‚Äú r√°meƒçku
          const samples = [
            { x: 0, y: cy - hh, z: -hd }, // horn√≠ hrana
            { x: hw, y: cy, z: -hd }, // prav√°
            { x: 0, y: cy + hh, z: -hd }, // doln√≠
            { x: -hw, y: cy, z: -hd } // lev√°
          ];

          for (const s of samples) {
            const p = projectPoint(s.x, s.y, s.z);
            const ch = letters[index % len];
            index++;

            const flicker =
              0.6 + 0.4 * Math.sin(signalCore.pulse * 2 + frame.phase);
            ctx.globalAlpha = flicker;
            ctx.fillText(ch, p.x, p.y);
          }
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      function drawGlyphMode() {
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 225, 180, 0.96)";
        ctx.shadowColor = "rgba(255, 200, 160, 0.8)";
        ctx.shadowBlur = 7;

        const len = glyphs.length;
        let index = 0;

        for (const frame of signalCore.frames) {
          const hw = frame.w / 2;
          const hh = frame.h / 2;
          const hd = frame.d / 2;
          const cy = frame.y;

          // ƒçty≈ôi body v roz√≠ch p≈ôedn√≠ho r√°meƒçku
          const samples = [
            { x: -hw, y: cy - hh, z: -hd },
            { x: hw, y: cy - hh, z: -hd },
            { x: hw, y: cy + hh, z: -hd },
            { x: -hw, y: cy + hh, z: -hd }
          ];

          for (const s of samples) {
            const p = projectPoint(s.x, s.y, s.z);
            const g = glyphs[index % len];
            index++;

            const flicker =
              0.55 + 0.45 * Math.sin(signalCore.pulse * 1.4 + frame.phase);
            ctx.globalAlpha = flicker;
            ctx.fillText(g, p.x, p.y);
          }
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      }

      function drawVafitiMode() {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255, 210, 160, 0.9)";
        ctx.fillStyle = "rgba(255, 210, 160, 0.35)";

        for (const frame of signalCore.frames) {
          const hw = frame.w / 2;
          const hh = frame.h / 2;
          const hd = frame.d / 2;
          const cy = frame.y;

          const corners = [
            { x: -hw, y: cy - hh, z: -hd },
            { x: hw, y: cy - hh, z: -hd },
            { x: hw, y: cy + hh, z: -hd },
            { x: -hw, y: cy + hh, z: -hd },
            { x: -hw, y: cy - hh, z: hd },
            { x: hw, y: cy - hh, z: hd },
            { x: hw, y: cy + hh, z: hd },
            { x: -hw, y: cy + hh, z: hd }
          ];

          for (const c of corners) {
            const p = projectPoint(c.x, c.y, c.z);
            const wobble =
              Math.sin(signalCore.pulse * 3 + frame.phase) * 2.3;
            const size =
              2.3 + 1.2 * Math.sin(signalCore.pulse * 2 + frame.phase);

            ctx.beginPath();
            ctx.arc(p.x, p.y - wobble, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }
        }
      }

      function drawSignalCore() {
        drawBackground();

        // jemn√Ω ‚Äûku≈æelov√Ω‚Äú glow p≈ôes celou vƒõ≈æ r√°meƒçk≈Ø
        ctx.save();
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = "rgba(255, 200, 150, 0.35)";

        const topY = getFrameCenterScreenY(0);
        const bottomY = getFrameCenterScreenY(
          signalCore.frames.length - 1
        );
        const middleX = width / 2 + viewOffsetX;

        ctx.beginPath();
        ctx.moveTo(middleX - baseRadius * viewScale * 1.1, bottomY + 10);
        ctx.lineTo(middleX, topY - 30);
        ctx.lineTo(middleX + baseRadius * viewScale * 1.1, bottomY + 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        const mode = modes[modeIndex];

        switch (mode) {
          case "mesh":
            drawMeshMode();
            break;
          case "letters":
            drawLettersMode();
            break;
          case "glyph":
            drawGlyphMode();
            break;
          case "vafiti":
            drawVafitiMode();
            break;
        }

        // st≈ôedov√° teƒçka (j√°dro)
        ctx.beginPath();
        ctx.arc(
          width / 2 + viewOffsetX,
          height / 2 + viewOffsetY,
          3,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(255, 220, 180, 0.9)";
        ctx.fill();
      }

      // animace
      let lastTime = 0;
      function loop(timestamp) {
        if (!timestamp) timestamp = 0;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        signalCore.pulse += dt;

        const k = Math.min(1, 6 * dt);
        viewScale += (targetViewScale - viewScale) * k;
        tiltX += (targetTiltX - tiltX) * k;
        tiltY += (targetTiltY - tiltY) * k;

        drawSignalCore();
        requestAnimationFrame(loop);
      }

      // interakce ‚Äì n√°klon + p≈ôep√≠n√°n√≠ re≈æimu
      let dragging = false;
      let lastX = 0;
      let lastY = 0;
      let moved = 0;

      function pointerDown(e) {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        dragging = true;
        lastX = touch.clientX;
        lastY = touch.clientY;
        moved = 0;
      }

      function pointerMove(e) {
        if (!dragging) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX;
        const y = touch.clientY;
        const dx = x - lastX;
        const dy = y - lastY;
        lastX = x;
        lastY = y;
        moved += Math.abs(dx) + Math.abs(dy);

        targetTiltY += dx * 0.01;
        targetTiltX += dy * 0.01;
      }

      function pointerUp(e) {
        if (!dragging) return;
        dragging = false;

        if (moved < 10) {
          modeIndex = (modeIndex + 1) % modes.length;
          const mode = modes[modeIndex];
          let label = "";
          if (mode === "mesh") label = "s√≠≈• r√°meƒçk≈Ø";
          else if (mode === "letters") label = "p√≠smena na hran√°ch";
          else if (mode === "glyph") label = "VaFiT glyph r√°meƒçky";
          else if (mode === "vafiti") label = "VafiT'i kapky na roz√≠ch";
          modeLabel.textContent = "re≈æim: " + label;
        }
      }

      canvas.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      canvas.addEventListener("touchstart", pointerDown, { passive: false });
      window.addEventListener("touchmove", pointerMove, { passive: false });
      window.addEventListener("touchend", pointerUp, { passive: false });
      window.addEventListener("touchcancel", pointerUp, { passive: false });

      // zoom koleƒçkem
      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        targetViewScale *= factor;
        targetViewScale = Math.max(0.6, Math.min(2.5, targetViewScale));
      });

      resize();
      window.addEventListener("resize", resize);
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
