<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VaFT • Glyph Sphere</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #120507, #020103);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
    }
    .label {
      position: fixed;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      font-size: 11px;
      opacity: 0.65;
      pointer-events: none;
      text-align: center;
    }
  </style>
</head>
<body>

<canvas id="sphere"></canvas>
<div class="label">
  VaFT • Koule z glyphů (červená + bílá) podle tvé 4×4 tabulky
</div>

<script>
(function () {
  "use strict";

  const canvas = document.getElementById("sphere");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener("resize", resize);

  // 4×4 tabulka – můžeš kdykoliv změnit na své znaky
  const glyphGrid = [
    "ː", "¦", "∙", "!",
    "a", "b", "c", "^",
    "1", "2", "3", "4",
    "#", ".", "A", ")"
  ];

  // méně bodů = plynulejší animace
  const latSteps = 16;   // řádky
  const lonSteps = 32;   // sloupce

  let rotation = 0;
  let lastTime = 0;

  function draw(time) {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const cx = w / 2;
    const cy = h / 2;                  // STŘED obrazovky
    const radius = Math.min(w, h) * 0.26; // menší, aby se vešla celá koule

    // deltaTime pro plynulou rotaci
    const dt = lastTime ? (time - lastTime) : 16;
    lastTime = time;
    rotation += dt * 0.0004;           // rychlost rotace

    ctx.clearRect(0, 0, w, h);

    // pozadí
    const bg = ctx.createRadialGradient(cx, cy - 60, 40, cx, cy, Math.max(w, h));
    bg.addColorStop(0, "#2a1214");
    bg.addColorStop(0.45, "#0b0507");
    bg.addColorStop(1, "#020103");
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);

    // jemná "podložka" pod koulí
    ctx.save();
    ctx.translate(cx, cy + radius * 1.05);
    ctx.scale(1.6, 0.4);
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
    const baseGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.8);
    baseGrad.addColorStop(0, "rgba(255,255,255,0.06)");
    baseGrad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = baseGrad;
    ctx.fill();
    ctx.restore();

    // předvykreslené styly – nebudeme tvořit gradient pro každý bod
    function pointColor(depth) {
      const white = 0.4 + depth * 0.6;
      const red   = 0.6 + (1 - depth) * 0.4;
      // trochu víc do bíla vpředu
      const r = Math.floor(255 * (0.6 * red + 0.4 * white));
      const g = Math.floor(255 * (0.3 * red + 0.7 * white));
      const b = Math.floor(255 * (0.3 * red + 0.7 * white));
      const a = 0.55 + depth * 0.35;
      return `rgba(${r},${g},${b},${a})`;
    }

    // samotná koule
    for (let i = 0; i <= latSteps; i++) {
      const v = i / latSteps;
      const lat = (v - 0.5) * Math.PI;          // -π/2 .. π/2

      for (let j = 0; j < lonSteps; j++) {
        const u = j / lonSteps;
        const lon = u * Math.PI * 2 + rotation;

        const x = Math.cos(lat) * Math.cos(lon);
        const y = Math.sin(lat);
        const z = Math.cos(lat) * Math.sin(lon);

        const depth = (z + 1) / 2;             // 0 .. 1
        // ignoruj zadní stranu – menší počet bodů = víc fps
        if (depth < 0.15) continue;

        const r = radius * (0.9 + depth * 0.12);
        const px = cx + x * r;
        const py = cy + y * r;

        const size = 1.2 + depth * 2.0;

        // kulatý bod
        ctx.beginPath();
        ctx.arc(px, py, size, 0, Math.PI * 2);
        ctx.fillStyle = pointColor(depth);
        ctx.fill();

        // glyph jen u části bodů, jinak by to bylo moc husté
        if (depth > 0.45 && (i + j) % 3 === 0) {
          const idx = (i * lonSteps + j) % glyphGrid.length;
          const glyph = glyphGrid[idx];
          ctx.save();
          ctx.translate(px, py);
          ctx.font = `${7 + depth * 4}px monospace`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillStyle = depth > 0.7
            ? "rgba(255,255,255,0.95)"
            : "rgba(255,220,220,0.85)";
          ctx.fillText(glyph, 0, 0);
          ctx.restore();
        }
      }
    }

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>

</body>
</html>
